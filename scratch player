
<!DOCTYPE html>
<meta charset=utf-8>
<title>Scratch HTML5</title>

<!-- iPad properties: set width, disable pinch zoom -->
<meta name=apple-mobile-web-app-capable content=yes>
<meta name=viewport content="user-scalable=no, width=540">
<meta name=apple-mobile-web-app-status-bar-style content=black>

<link rel=stylesheet href=player.css>
<link rel=stylesheet href=index.css>

<script src=http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js></script>


<script type="text/javascript">
  $(document).ready(function() {
    var project_id = location.hash && parseInt(location.hash.substr(1)) || 10000160;
    var scratch = new Scratch(project_id);
  });
</script>

<div id=player-container>
    <div class="arrow vertical" id=up></div>
    <div class="arrow vertical" id=down></div>
    <div class="arrow horizontal" id=left></div>
    <div class="arrow horizontal" id=right></div>
    <div id=player-header>
        <div id=player-header-preload></div>
        <div id=player-header-version>HTML5</div>
        <button id=toggle-fullscreen tabindex=1></button>
        <button id=trigger-stop tabindex=3></button>
        <button id=trigger-green-flag tabindex=2></button>
    </div>
    <div id=player-content>
        <div id=container></div>
        <div id=overlay></div>
        <div id=preloader>
            <div id=preloader-progress><div id=preloader-progress-bar></div></div>
            <div id=preloader-caption>Loading project&hellip;</div>
            <div id=preloader-details></div>
        </div>
    </div>
</div>

<div id=project-picker>
    <span id=address-hint>http://scratch.mit.edu/projects/</span><input id=project-id placeholder=10000160><button id=go-project>&rarr;</button>
</div>

<h1>Scratch HTML5 player</h1>
<p>The Scratch HTML5 player is still in development. Feedback is welcome! Please report any bugs (or differences from the Flash player)
<script src=js/util/Timer.js></script>
<script src=js/util/OffsetBuffer.js></script>
<script src=js/util/Color.js></script>
<script src=js/util/Rectangle.js></script>
<script src=js/Sprite.js></script>
<script src=js/Reporter.js></script>
<script src=js/Stage.js></script>
<script src=js/sound/WAVFile.js></script>
<script src=js/sound/SoundDecoder.js></script>
<script src=js/sound/SoundBank.js></script>
<script src=js/sound/NotePlayer.js></script>
<script src=soundbank/Instr.js></script>
<script src=js/IO.js></script>
<script src=js/primitives/VarListPrims.js></script>
<script src=js/primitives/MotionAndPenPrims.js></script>
<script src=js/primitives/LooksPrims.js></script>
<script src=js/primitives/SensingPrims.js></script>
<script src=js/primitives/SoundPrims.js></script>
<script src=js/primitives/Primitives.js></script>
<script src=js/Interpreter.js></script>
<script src=js/Runtime.js></script>
<!-- <script src=js/Scratch.js></script> -->
<script type="text/JavaScript" src="js/Scratch.js"></script> 


/*index.css*/

body {
    width: 578px;
    padding: 16px;
    margin: 0 auto;
    background: #fff;
    font-family: sans-serif;
    color: #000;
}

/*compare.css*/

body {
    background: #fff;
    font-family: sans-serif;
    color: #000;
    width: 1108px;
    margin: 0 auto;
}

.container {
    display: inline-block;
    vertical-align: top;
}

textarea {
    width: 482px;
    padding: 6px;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    height: 200px;
    display: block;
    margin: 16px auto;
    border: 1px solid #aaa;
    box-shadow: inset 3px 3px 3px -3px rgba(0, 0, 0, .3);
}

#flash-scratch {
    text-align: center;
    visibility: hidden;
    display: block;
    margin: 48px 0 62px;
}

#flash-scratch p {
    color: #aaa;
    font-size: 22px;
    margin-top: 14px;
    line-height: 28px;
}



/*player.css*/

/* Wrapper wraps the entire player, and the text below and above. Ideally,
   all CSS selectors would be descendants of #wrapper so that the player
   is embeddable.
*/
#player-container {
    position: relative;
    width: 482px;
    padding: 48px;
    margin: 0 auto;
    font-family: sans-serif;
    /* Before, we accomplished this with e.preventDefault
     * on the context div.  But, we'd like to use those click events
     * for some things like reporter sliders.
     */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/*  Control bar above the stage */
#player-header {
    width: 480px;
    height: 38px;
    position: relative;
    background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#e6e6e6));
    background: -webkit-linear-gradient(#fff, #e6e6e6);
    background: -moz-linear-gradient(#fff, #e6e6e6);
    background: -ms-linear-gradient(#fff, #e6e6e6);
    background: -o-linear-gradient(#fff, #e6e6e6);
    background: linear-gradient(#fff, #e6e6e6);
    border: 1px solid #d1d1d1;
    border-bottom: 0;
    border-radius: 7px 7px 0 0;
}

/* Button styling */
#player-header button {
    border: 0;
    background: center center no-repeat;
    width: 33px;
    height: 38px;
    float: right;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}
#player-header-preload {
    width: 1px;
    height: 1px;
    position: absolute;
    top: -1px;
    left: -1px;
    background: url(img/fullScreenOn.png), url(img/greenFlagOn.png), url(img/stopOn.png);
}
button#toggle-fullscreen {
    background-image: url(img/fullScreenOff.png);
    background-position: 10px 8px;
    width: 40px;
    position: absolute;
    top: 0;
    left: 0;
}
button#trigger-green-flag {
    background-image: url(img/greenFlagOff.png);
}
button#trigger-green-flag:hover {
    background-image: url(img/greenFlagOn.png);
}
button#trigger-stop {
    background-image: url(img/stopOff.png);
}
button#trigger-stop:hover {
    background-image: url(img/stopOn.png);
}

/* Version number */
#player-header-version {
    position: absolute;
    top: 28px;
    left: 0;
    width: 45px;
    text-align: center;
    color: rgba(0, 0, 0, .4);
    font: 9px sans-serif;
}

/* Wrapper for the Stage */
#player-content {
    position: relative;
    border: 1px solid #d1d1d1;
    border-top: 0;
    width: 480px;
    height: 360px;
}

/* The Stage */
#container {
    position: absolute;
    top: 0;
    left: 0;
    width: 480px;
    height: 360px;
    cursor: default;
    overflow: hidden;
}

/* Pane over the Stage with the green flag on startup */
#overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 480px;
    height: 360px;
    z-index: 10000;
    background: url(img/playerStartFlag.png) rgba(0, 0, 0, .26) center center no-repeat;
}

/* Preloader */
#preloader {
    position: absolute;
    z-index: 10001;
    top: 50%;
    left: 50%;
    margin-left: -156px;
    margin-top: -61px;
    width: 309px;
    height: 119px;
    border: 1px solid rgb(208, 209, 210);
    background: #fff;
    border-radius: 12px;
    -webkit-box-shadow: 4px 4px 6px rgba(0, 0, 0, .5);
    box-shadow: 4px 4px 6px rgba(0, 0, 0, .5);
    cursor: default;
}
#preloader-progress {
    margin: 24px 30px 14px 29px;
    background: rgb(185, 187, 189);
    border-radius: 5px;
    height: 22px;
}
#preloader-progress-bar {
    height: 22px;
    background: rgb(0, 161, 216);
    border-radius: 5px;
    width: 0;
}
#preloader-caption,
#preloader-details {
    margin: 14px 0 0 8px;
    text-align: center;
    font-size: 18px;
    color: rgba(0, 0, 0, .65);
}
#preloader-details {
    margin: 6px 0 0 4px;
    font-size: 12px;
}

/* iPad arrow key frame */
.arrow {
    position: absolute;
    top: 0;
    left: 0;
    width: 578px;
    height: 400px;
    text-align: center;
    font: 24px/48px sans-serif;
    color: rgba(0, 0, 0, .2);
    cursor: default;
}
.arrow.vertical {
    height: 48px;
}
.arrow.horizontal {
    width: 48px;
    top: 48px;
    line-height: 400px;
}
#right {
    left: 530px;
}
#down {
    top: 448px;
}
#up::before {
    content: '\25b2';
}
#down::before {
    content: '\25bc';
}
#left::before {
    content: '\25c0';
}
#right::before {
    content: '\25b6';
}

/* Panel for project ID input */
#project-picker {
    margin: 16px 0;
    text-align: center;
    font-size: 16px;
    line-height: 18px;
}
#project-id {
    border: 1px solid #aaa;
    -webkit-border-radius: 0;
    padding: 6px;
    -webkit-box-shadow: inset 3px 3px 3px -3px rgba(0, 0, 0, .3);
    box-shadow: inset 3px 3px 3px -3px rgba(0, 0, 0, .3);
    background: 0;
    margin: 0;
    font: inherit;
    width: 6em;
    position: relative;
}
#project-id.error {
    background: #fee;
    -webkit-box-shadow: inset 3px 3px 3px -3px rgba(100, 0, 0, .3);
    box-shadow: inset 3px 3px 3px -3px rgba(100, 0, 0, .3);
}
#project-id:focus {
    z-index: 1;
}
#address-hint {
    padding-left: 6px;
    vertical-align: middle;
}
#go-project {
    padding: 6px;
    margin: 0;
    border: 1px solid #aaa;
    border-left: 0;
    font: inherit;
    background: -webkit-gradient(linear, left top, left bottom, from(#fff), to(#ddd));
    background: -webkit-linear-gradient(#fff, #ddd);
    background: -moz-linear-gradient(#fff, #ddd);
    background: -ms-linear-gradient(#fff, #ddd);
    background: -o-linear-gradient(#fff, #ddd);
    background: linear-gradient(#fff, #ddd);
    -webkit-box-shadow: inset 0 -1px rgba(255, 255, 255, .2);
    box-shadow: inset 0 -1px rgba(255, 255, 255, .2);
    cursor: pointer;
    position: relative;
}
#go-project:active {
    background: -webkit-gradient(linear, left top, left bottom, from(#ddd), to(#eee));
    background: -webkit-linear-gradient(#ddd, #eee);
    background: -moz-linear-gradient(#ddd, #eee);
    background: -ms-linear-gradient(#ddd, #eee);
    background: -o-linear-gradient(#ddd, #eee);
    background: linear-gradient(#ddd, #eee);
    -webkit-box-shadow: inset 0 1px rgba(255, 255, 255, .3), inset 0 2px 5px rgba(0, 0, 0, .1);
    box-shadow: inset 0 1px rgba(255, 255, 255, .3), inset 0 2px 5px rgba(0, 0, 0, .1);
}

#project-id,
#go-project {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 18px;
    vertical-align: middle;
}
#go-project::-moz-focus-inner {
    border: 0;
    padding: 0;
}


/* Reporter styles */
.reporter-normal {
    display: inline-block;
    padding: 2px 7px 3px 5px;
    background-color: rgb(193, 196, 199);
    border: 1px solid rgb(148, 145, 145);
    border-radius: 6px;
    font: bold 11px/15px sans-serif;
    color: #000;
    position: absolute;
}
.reporter-inset {
    display: inline-block;
    vertical-align: top;
    min-width: 38px;
    margin-left: 6px;
    padding: 1px;
    border: 1px solid #fff;
    border-radius: 6px;
    -webkit-box-shadow: inset -1px -1px 3px rgba(255, 255, 255, 0.7), inset 1px 1px 2px rgba(0, 0, 0, 0.35);
    box-shadow: inset -1px -1px 3px rgba(255, 255, 255, 0.7), inset 1px 1px 2px rgba(0, 0, 0, 0.35);
    text-align: center;
    font: bold 9px/11px sans-serif;
    height: 11px;
    color: #fff;
}
.reporter-large {
    display: inline-block;
    min-width: 40px;
    padding: 2px 5px 1px 5px;
    border-radius: 4px;
    -webkit-box-shadow: 0 -3px 3px -3px #fff inset, -3px 0 3px -3px #fff inset, 0 3px 3px -3px #000 inset, 3px 0 3px -3px #000 inset;
    box-shadow: 0 -3px 3px -3px #fff inset, -3px 0 3px -3px #fff inset, 0 3px 3px -3px #000 inset, 3px 0 3px -3px #000 inset;
    font-family: bold 15px sans-serif;
    text-align: center;
    color: #fff;
    position: absolute;
}

/* List watcher styles */
.list {
    float: left;
    border-radius: 7px;
    -webkit-border-radius: 7px;
    -moz-border-radius: 7px;
    border-style: solid;
    border-color: gray;
    border-width: 2px;
    background-color: #C1C4C7;
    padding-left: 3px;
    font: bold 11px sans-serif;
    position: absolute;
}

.list .list-title {
    padding-top: 2px;
    text-align: center;
    color: black;
    font-weight: bold;
    margin-bottom: 4px;
}

.list .list-scrollbar-container {
    float: right;
    width: 10px;
    position: relative;
}

.list .list-scrollbar {
    position: absolute;
    top: 0px;
    width: 10px;
    background-color: #a8aaad;
    border-radius: 10px;
}

.list .list-index {
    color: rgb(81, 81, 81);
    float: left;
    padding: 2px;
    margin-top: 0px;
    text-align: right;
    font: bold 11px;
}

.list .list-item {
    float: right;
    height: 16px;
    overflow: hidden;
    margin-bottom: 0px;
    margin-right: 2px;
    padding-top: 2px;
    padding-left: 5px;
    border-color: white;
    border-style: solid;
    border-width: 1px;
    border-radius: 4px;
    background-color: #cc5b22;
    color: white;
    word-wrap: break-word;
    font: bolder 11px sans-serif;
}

.list .list-add {
    clear: both;
    background-color: #dedede;
    width: 12px;
    height: 12px;
    border-radius: 12px;
    color: #707070;
    font: bold 10px sans-serif;
    text-align: center;
    position: absolute;
    bottom: 2px;
    left: 2px;
}

.list .list-length {
    font-size: 10px;
    font-weight: normal;
    text-align: center;
    color: black;
    position: absolute;
    bottom: 2px;
    left: 0px;
    right: 0px;
}

/* Say/think bubble styles */
.bubble-container {
    position: absolute;
}
.bubble {
    position: relative;
    display: inline-block;
    max-width: 120px;
    min-width: 40px;
    padding: 6px 11px 6px 11px;
    border-radius: 10px;
    background: #fff;
    font-family: sans-serif;
    font-weight: bold;
    font-size: 14px;
    color: #000;
    text-align: center;
}
.bubble.say-think-border {
    border: 3px solid rgb(160, 160, 160);
}
.bubble.ask-border, .ask-container {
    border: 3px solid rgb(74, 173, 222);
}
.bubble-ask {
    position: absolute;
    margin-top: -3px;
    margin-left: 8px;
    width: 44px;
    height: 18px;
    background: url(img/ask-bottom.png) transparent no-repeat;
}
.bubble-say {
    position: absolute;
    margin-top: -3px;
    margin-left: 8px;
    width: 44px;
    height: 18px;
    background: url(img/say-bottom.png) transparent no-repeat;
}
.bubble-think {
    position: absolute;
    margin-top: 0px;
    margin-left: 8px;
    width: 44px;
    height: 19px;
    background: url(img/think-bottom.png) transparent no-repeat;
}
.ask-container {
    position: absolute;
    display: inline-block;
    padding: 5px 0px 0px 5px;
    border-radius: 5px;
    background: #fff;
    font-family: sans-serif;
    font-weight: bold;
    font-size: 14px;
    color: #000;
}
.ask-container .ask-field .ask-text-field {
    width: 405px;
    height: 16px;
    font-family: sans-serif;
    font-weight: light;
    font-size: 12px;
    background: #EAEAEA;
}

.ask-container .ask-button {
    position: absolute;
    right: 2px;
    top: 2px;
    width: 25px;
    height: 25px;
    background: url(img/ask-button.png) transparent no-repeat;
}




/*VarListPrims.js*/


'use strict';

var VarListPrims = function() {}

VarListPrims.prototype.addPrimsTo = function(primTable) {
    // Variable primitives
    primTable['readVariable']        = this.primReadVar;
    primTable['setVar:to:']          = this.primSetVar;
    primTable['changeVar:by:']       = this.primChangeVar;
    primTable['hideVariable:']       = this.primHideVar;
    primTable['showVariable:']       = this.primShowVar;

    // List primitives
    primTable['contentsOfList:']      = this.primReadList;
    primTable['append:toList:']      = this.primListAppend;
    primTable['deleteLine:ofList:']  = this.primListDeleteLine;
    primTable['insert:at:ofList:']   = this.primListInsertAt;
    primTable['setLine:ofList:to:']  = this.primListSetLine;
    primTable['lineCountOfList:']    = this.primListLength;
    primTable['getLine:ofList:']     = this.primListGetLine;
    primTable['list:contains:']      = this.primListContains;
    primTable['hideList:']       = this.primHideList;
    primTable['showList:']       = this.primShowList;
};

// Variable primitive implementations

VarListPrims.prototype.primReadVar = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    var targetVar = interp.arg(b, 0);
    if (targetVar in s.variables) {
        return s.variables[targetVar];
    } else if (targetVar in runtime.stage.variables) {
        return runtime.stage.variables[targetVar];
    }
};

VarListPrims.prototype.primSetVar = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    var targetVar = interp.arg(b, 0);
    if (targetVar in s.variables) {
        s.variables[targetVar] = interp.arg(b, 1);
    } else if (targetVar in runtime.stage.variables) {
        runtime.stage.variables[targetVar] = interp.arg(b, 1);
    }
};

VarListPrims.prototype.primChangeVar = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    var targetVar = interp.arg(b, 0);
    if (targetVar in s.variables) {
        s.variables[targetVar] = parseFloat(s.variables[targetVar]) + interp.numarg(b, 1);
    } else if (targetVar in runtime.stage.variables) {
        runtime.stage.variables[targetVar] = parseFloat(runtime.stage.variables[targetVar]) + interp.numarg(b, 1);
    }
};

VarListPrims.prototype.primHideVar = function(b) {
    var targetVar = interp.arg(b, 0), targetSprite = interp.targetSprite().objName;
    for (var r = 0; r < runtime.reporters.length; r++) {
        if (runtime.reporters[r].cmd == 'getVar:' && runtime.reporters[r].param == targetVar && (runtime.reporters[r].target == targetSprite || runtime.reporters[r].target == 'Stage')) {
            runtime.reporters[r].visible = false;
            return;
        }
    }
};

VarListPrims.prototype.primShowVar = function(b) {
    var targetVar = interp.arg(b, 0), targetSprite = interp.targetSprite().objName;
    for (var r = 0; r < runtime.reporters.length; r++) {
        if (runtime.reporters[r].cmd == 'getVar:' && runtime.reporters[r].param == targetVar && (runtime.reporters[r].target == targetSprite || runtime.reporters[r].target == 'Stage')) {
            runtime.reporters[r].visible = true;
            return;
        }
    }
};

// List primitive implementations

// Take a list name and target sprite and return the JS list itself
function findList(targetSprite, listName) {
    if (targetSprite == null) targetSprite = runtime.stage;
    if (listName in targetSprite.lists) {
        return targetSprite.lists[listName].contents;
    } else if (listName in runtime.stage.lists) {
        return runtime.stage.lists[listName].contents;
    }
    return null;
}

VarListPrims.prototype.primReadList = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 0));
    if (list) {
        var allOne = list.map(function(val) { return val.length; }).reduce(function(old,val) { return old + val; }, 0) === list.length;
        return list.join(allOne ? '' : ' ');
    }
};

VarListPrims.prototype.primListAppend = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 1));
    if (list) list.push(interp.arg(b, 0));
};

VarListPrims.prototype.primListDeleteLine = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 1));
    if (!list) return;
    var line = interp.arg(b, 0);
    if (line == 'all' || list.length == 0) {
        list.length = 0;
    } else if (line == 'last') {
        list.splice(list.length - 1, 1);
    } else if (parseInt(line, 10) - 1 in list) {
        list.splice(parseInt(line, 10) - 1, 1);
    }
};

VarListPrims.prototype.primListInsertAt = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 2));
    if (!list) return;
    var newItem = interp.arg(b, 0);

    var position = interp.arg(b, 1);
    if (position == 'last') {
        position = list.length;
    } else if (position == 'random') {
        position = Math.round(Math.random() * list.length);
    } else {
        position = parseInt(position, 10) - 1;
    }
    if (position > list.length) return;

    list.splice(position, 0, newItem);
};

VarListPrims.prototype.primListSetLine = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 1));
    if (!list) return;
    var newItem = interp.arg(b, 2);
    var position = interp.arg(b, 0);

    if (position == 'last') {
        position = list.length - 1;
    } else if (position == 'random') {
        position = Math.floor(Math.random() * list.length);
    } else {
        position = parseInt(position, 10) - 1;
    }

    if (position > list.length - 1) return;
    list[position] = newItem;
};

VarListPrims.prototype.primListLength = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 0));
    if (!list) return 0;
    return list.length;
};

VarListPrims.prototype.primListGetLine = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 1));
    if (!list) return 0;
    var line = interp.arg(b, 0);
    if (list.length == 0) return 0;
    if (line == 'random') line = Math.round(Math.random() * list.length);
    else if (line == 'last') line = list.length;
    else if (list.length < line) return 0;
    return list[line - 1];
};

VarListPrims.prototype.primListContains = function(b) {
    var list = findList(interp.targetSprite(), interp.arg(b, 0));
    if (!list) return 0;
    var searchItem = interp.arg(b, 1);
    if (parseFloat(searchItem) == searchItem) searchItem = parseFloat(searchItem);
    return $.inArray(searchItem, list) > -1;
};

VarListPrims.prototype.primHideList = function(b) {
    var targetList = interp.arg(b, 0), targetSprite = interp.targetSprite().objName;
    for (var r = 0; r < runtime.reporters.length; r++) {
        if (runtime.reporters[r] instanceof List && runtime.reporters[r].listName == targetList && (runtime.reporters[r].target == targetSprite || runtime.reporters[r].target == 'Stage')) {
            runtime.reporters[r].visible = false;
            return;
        }
    }
};

VarListPrims.prototype.primShowList = function(b) {
    var targetList = interp.arg(b, 0), targetSprite = interp.targetSprite().objName;
    for (var r = 0; r < runtime.reporters.length; r++) {
        if (runtime.reporters[r] instanceof List && runtime.reporters[r].listName == targetList && (runtime.reporters[r].target == targetSprite || runtime.reporters[r].target == 'Stage')) {
            runtime.reporters[r].visible = true;
            return;
        }
    }
};


/*SoundPrims.js*/


'use strict';

var SoundPrims = function() {};

SoundPrims.prototype.addPrimsTo = function(primTable) {
    primTable['playSound:'] = this.primPlaySound;
    primTable['doPlaySoundAndWait'] = this.primPlaySoundUntilDone;
    primTable['stopAllSounds'] = this.primStopAllSounds;

    primTable['playDrum'] = this.primPlayDrum;
    primTable['rest:elapsed:from:'] = this.primPlayRest;
    primTable['noteOn:duration:elapsed:from:'] = this.primPlayNote;
    primTable['instrument:'] = this.primSetInstrument;

    /*primTable['changeVolumeBy:'] = this.primChangeVolume;
    primTable['setVolumeTo:'] = this.primSetVolume;
    primTable['volume'] = this.primVolume;*/

    primTable['changeTempoBy:'] = function(b) { runtime.stage.data.tempoBPM = runtime.stage.data.tempoBPM + interp.arg(b, 0); };
    primTable['setTempoTo:'] = function(b) { runtime.stage.data.tempoBPM = interp.arg(b, 0); };
    primTable['tempo'] = function(b) { return runtime.stage.data.tempoBPM; };
};

var playSound = function(snd) {
    if (snd.source) {
        // If this particular sound is already playing, stop it.
        snd.source.disconnect();
        snd.source = null;
    }

    snd.source = runtime.audioContext.createBufferSource();
    snd.source.buffer = snd.buffer;
    snd.source.connect(runtime.audioGain);

    // Track the sound's completion state
    snd.source.done = false;
    snd.source.finished = function() {
        // Remove from the active audio list and disconnect the source from
        // the sound dictionary.
        var i = runtime.audioPlaying.indexOf(snd);
        if (i > -1 && runtime.audioPlaying[i].source != null) {
            runtime.audioPlaying[i].source.done = true;
            runtime.audioPlaying[i].source = null;
            runtime.audioPlaying.splice(i, 1);
        }
    }
    window.setTimeout(snd.source.finished, snd.buffer.duration * 1000);
    // Add the global list of playing sounds and start playing.
    runtime.audioPlaying.push(snd);
    snd.source.start();
    return snd.source;
};

var playDrum = function(drum, secs, client) {
    var player = SoundBank.getDrumPlayer(drum, secs);
    player.client = client;
    player.setDuration(secs);
    var source = runtime.audioContext.createScriptProcessor(4096, 1, 1);
    source.onaudioprocess = function(e) { player.writeSampleData(e); };
    source.soundPlayer = player;
    source.connect(runtime.audioGain);
    runtime.notesPlaying.push(source);
    source.finished = function() {
        var i = runtime.notesPlaying.indexOf(source);
        if (i > -1 && runtime.notesPlaying[i] != null) {
            runtime.notesPlaying.splice(i, 1);
        }
    }
    window.setTimeout(source.finished, secs * 1000);
    return player;
};

var playNote = function(instrument, midiKey, secs, client) {
    var player =  SoundBank.getNotePlayer(instrument, midiKey);
    player.client = client;
    player.setNoteAndDuration(midiKey, secs);
    var source = runtime.audioContext.createScriptProcessor(4096, 1, 1);
    source.onaudioprocess = function(e) { player.writeSampleData(e); };
    source.connect(runtime.audioGain);
    runtime.notesPlaying.push(source);
    source.finished = function() {
        var i = runtime.notesPlaying.indexOf(source);
        if (i > -1 && runtime.notesPlaying[i] != null) {
            runtime.notesPlaying.splice(i, 1);
        }
    }
    window.setTimeout(source.finished, secs * 1000);
    return player;
};

var stopAllSounds = function() {
    var oldPlaying = runtime.audioPlaying;
    runtime.audioPlaying = [];
    for (var s = 0; s < oldPlaying.length; s++) {
        if (oldPlaying[s].source) {
            oldPlaying[s].source.disconnect();
            oldPlaying[s].source.finished();
        }
    }

    var oldPlaying = runtime.notesPlaying;
    runtime.notesPlaying = [];
    for (var s = 0; s < oldPlaying.length; s++) {
        if (oldPlaying[s]) {
            oldPlaying[s].disconnect();
            oldPlaying[s].finished();
        }
    }
};

SoundPrims.prototype.primPlaySound = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    var snd = s.soundNamed(interp.arg(b, 0));
    if (snd != null) playSound(snd);
};

SoundPrims.prototype.primPlaySoundUntilDone = function(b) {
    var activeThread = interp.activeThread;
    if (activeThread.firstTime) {
        var snd = interp.targetSprite().soundNamed(interp.arg(b, 0));
        if (snd == null) return;
        activeThread.tmpObj = playSound(snd);
        activeThread.firstTime = false;
    }
    var player = activeThread.tmpObj;
    if (player == null || player.done || player.playbackState == 3) {
        activeThread.tmpObj = null;
        activeThread.firstTime = true;
    } else {
        interp.yield = true;
    }
};

var beatsToSeconds = function(beats) {
    return beats * 60 / runtime.stage.data.tempoBPM;
};

SoundPrims.prototype.primPlayNote = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    if (interp.activeThread.firstTime) {
        var key = interp.numarg(b, 0);
        var secs = beatsToSeconds(interp.numarg(b, 1));
        playNote(s.instrument, key, secs, s);
        interp.startTimer(secs);
    } else {
        interp.checkTimer();
    }
};

SoundPrims.prototype.primPlayDrum = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    if (interp.activeThread.firstTime) {
        var drum = Math.round(interp.numarg(b, 0));
        var secs = beatsToSeconds(interp.numarg(b, 1));
        playDrum(drum, secs, s);
        interp.startTimer(secs);
    } else {
        interp.checkTimer();
    }
};

SoundPrims.prototype.primPlayRest = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    if (interp.activeThread.firstTime) {
        var secs = beatsToSeconds(interp.numarg(b, 0));
        interp.startTimer(secs);
    } else {
        interp.checkTimer();
    }
};

SoundPrims.prototype.primSetInstrument = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.instrument = interp.arg(b, 0);
};

SoundPrims.prototype.primStopAllSounds = function(b) {
    stopAllSounds();
};

SoundPrims.prototype.primChangeVolume = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.volume += interp.numarg(b, 0);
};

SoundPrims.prototype.primSetVolume = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.volume = interp.numarg(b, 0);
};

SoundPrims.prototype.primVolume = function(b) {
    var s = interp.targetSprite();
    return s != null ? s.volume : 0;
};


/*SensingPrims.js*/



'use strict';

var SensingPrims = function() {};

SensingPrims.prototype.addPrimsTo = function(primTable) {
    primTable['touching:']      = this.primTouching;
    primTable['touchingColor:'] = this.primTouchingColor;
    primTable['color:sees:']    = this.primColorTouchingColor;

    primTable['doAsk']              = this.primDoAsk;
    primTable['answer']             = this.primAnswer;

    primTable['keyPressed:']  = this.primKeyPressed;
    primTable['mousePressed'] = function(b) { return runtime.mouseDown; };
    primTable['mouseX']       = function(b) { return runtime.mousePos[0]; };
    primTable['mouseY']       = function(b) { return runtime.mousePos[1]; };
    primTable['distanceTo:']  = this.primDistanceTo;

    primTable['getAttribute:of:'] = this.primGetAttribute;

    primTable['timeAndDate']  = function(b) { return runtime.getTimeString(interp.arg(b, 0)); };
    primTable['timestamp'] = this.primTimestamp;
};

SensingPrims.prototype.primTouching = function(b) {
    var s = interp.targetSprite();
    if (s == null || !s.visible) return false;

    var arg = interp.arg(b, 0);
    if (arg == '_edge_') {
        return false; // TODO
    }

    if (arg == '_mouse_') {
        return false; // TODO
    }

    var s2 = runtime.spriteNamed(arg);
    if (s2 == null || !s2.visible) return false;

    return spriteHitTest(s, s2);
};

SensingPrims.prototype.primTouchingColor = function(b) {
    var s = interp.targetSprite();
    if (s == null || !s.visible) return false;

    var color = interp.arg(b, 0);

    return stageColorHitTest(s, color);
};

SensingPrims.prototype.primColorTouchingColor = function(b) {
    var s = interp.targetSprite();
    if (s == null || !s.visible) return false;

    var myColor = interp.arg(b, 0);
    var stageColor = interp.arg(b, 1);

    return stageColorByColorHitTest(s, myColor, stageColor);
};

var spriteHitTest = function(a, b) {
    var hitCanvas = document.createElement('canvas');
    hitCanvas.width = 480;
    hitCanvas.height = 360;
    var hitTester = hitCanvas.getContext('2d');
    hitTester.globalCompositeOperation = 'source-over';
    a.stamp(hitTester, 100);
    hitTester.globalCompositeOperation = 'source-in';
    b.stamp(hitTester, 100);

    var aData = hitTester.getImageData(0, 0, 480, 360).data;

    var pxCount = aData.length;
    for (var i = 0; i < pxCount; i += 4) {
        if (aData[i+3] > 0) {
            return true;
        }
    }
    return false;
};

var stageColorHitTest = function(target, color) {
    var r, g, b;
    r = (color >> 16);
    g = (color >> 8 & 255);
    b = (color & 255);

    var targetCanvas = document.createElement('canvas');
    targetCanvas.width = 480;
    targetCanvas.height = 360;
    var targetTester = targetCanvas.getContext('2d');
    target.stamp(targetTester, 100);

    var stageCanvas = document.createElement('canvas');
    stageCanvas.width = 480;
    stageCanvas.height = 360;
    var stageContext = stageCanvas.getContext('2d');

    $.each(runtime.sprites, function(i, sprite) {
        if (sprite != target)
            sprite.stamp(stageContext, 100);
    });

    var hitData = stageContext.getImageData(0, 0, stageCanvas.width, stageCanvas.height).data;
    var meshData = targetTester.getImageData(0, 0, targetCanvas.width, targetCanvas.height).data;
    var pxCount = meshData.length;
    for (var i = 0; i < pxCount; i += 4) {
        if (meshData[i+3] > 0 && hitData[i] == r && hitData[i+1] == g && hitData[i+2] == b)
            return true;
    }
    return false;
};

var stageColorByColorHitTest = function(target, myColor, otherColor) {
    var threshold_acceptable = function(a, b, c, x, y, z) {
        var diff_a = Math.abs(a-x);
        var diff_b = Math.abs(b-y);
        var diff_c = Math.abs(c-z);
        if (diff_a + diff_b + diff_c < 100) {
            return true;
        }
        return false;
    };
    var targetCanvas = document.createElement('canvas');
    targetCanvas.width = 480;
    targetCanvas.height = 360;
    var targetTester = targetCanvas.getContext('2d');
    target.stamp(targetTester, 100);
    var targetData = targetTester.getImageData(0, 0, targetCanvas.width, targetCanvas.height).data;

    // Calculate RGB values of the colors - TODO thresholding
    //myColor = Math.abs(myColor);
    //otherColor = Math.abs(otherColor);
    var mr, mg, mb, or, og, ob;
    mr = (myColor >> 16);
    mg = (myColor >> 8 & 255);
    mb = (myColor & 255);
    or = (otherColor >> 16);
    og = (otherColor >> 8 & 255);
    ob = (otherColor & 255);

    // Create the hit canvas for comparison
    var hitCanvas = document.createElement('canvas');
    hitCanvas.width = 480;
    hitCanvas.height = 360;
    var hitCtx = hitCanvas.getContext('2d');
    $.each(runtime.sprites, function(i, sprite) {
        if (sprite != target) {
            sprite.stamp(hitCtx, 100);
        }
    });

    var hitData = hitCtx.getImageData(0, 0, hitCanvas.width, hitCanvas.height).data;
    var pxCount = targetData.length;
    for (var i = 0; i < pxCount; i += 4) {
        if (threshold_acceptable(targetData[i], targetData[i+1], targetData[i+2], mr, mg, mb) && threshold_acceptable(hitData[i], hitData[i+1], hitData[i+2], or, og, ob)) {
            return true;
        }
    }
    return false;
};

SensingPrims.prototype.primDoAsk= function(b) {
    showBubble(b, "doAsk");
    var s = interp.targetSprite();
    if (s !== null) {
        interp.activeThread.paused = true;
        s.showAsk();
    }
};

SensingPrims.prototype.primAnswer = function(b) {
    var s = interp.targetStage();
    return (s !== null ? s.askAnswer : undefined);
};


SensingPrims.prototype.primKeyPressed = function(b) {
    var key = interp.arg(b, 0);
    var ch = key.charCodeAt(0);
    if (ch > 127) return false;
    if (key == "left arrow") ch = 37;
    if (key == "right arrow") ch = 39;
    if (key == "up arrow") ch = 38;
    if (key == "down arrow") ch = 40;
    if (key == "space") ch = 32;
    return (typeof(runtime.keysDown[ch]) != 'undefined');
};

SensingPrims.prototype.primDistanceTo = function(b) {
    var s = interp.targetSprite();
    var p = mouseOrSpritePosition(interp.arg(b, 0));
    if (s == null || p == null) return 0;
    var dx = p.x - s.scratchX;
    var dy = p.y - s.scratchY;
    return Math.sqrt((dx * dx) + (dy * dy));
};

SensingPrims.prototype.primGetAttribute = function(b) {
    var attr = interp.arg(b, 0);
    var targetSprite = runtime.spriteNamed(interp.arg(b, 1));
    if (targetSprite == null) return 0;
    if (attr == 'x position') return targetSprite.scratchX;
    if (attr == 'y position') return targetSprite.scratchY;
    if (attr == 'direction') return targetSprite.direction;
    if (attr == 'costume #') return targetSprite.currentCostumeIndex + 1;
    if (attr == 'costume name') return targetSprite.costumes[targetSprite.currentCostumeIndex]['costumeName'];
    if (attr == 'size') return targetSprite.getSize();
    if (attr == 'volume') return targetSprite.volume;
    return 0;
};

SensingPrims.prototype.primTimeDate = function(b) {
    var dt = interp.arg(b, 0);
    var now = new Date();
    if (dt == 'year') return now.getFullYear();
    if (dt == 'month') return now.getMonth()+1;
    if (dt == 'date') return now.getDate();
    if (dt == 'day of week') return now.getDay()+1;
    if (dt == 'hour') return now.getHours();
    if (dt == 'minute') return now.getMinutes();
    if (dt == 'second') return now.getSeconds();
    return 0;
};

SensingPrims.prototype.primTimestamp = function(b) {
    var now = new Date();
    var epoch = new Date(2000, 0, 1);
    var dst = now.getTimezoneOffset() - epoch.getTimezoneOffset();
    var msSince = now.getTime() - epoch.getTime();
    msSince -= dst * 60000;
    return msSince / 86400000;
};

// Helpers
SensingPrims.prototype.mouseOrSpritePosition = function(arg) {
    if (arg == "_mouse_") {
        var w = runtime.stage;
        return new Point(runtime.mousePos[0], runtime.mousePos[1]);
    } else {
        var s = runtime.spriteNamed(arg);
        if (s == null) return null;
        return new Point(s.scratchX, s.scratchY);
    }
    return null;
};


/*Primitives.js*/



'use strict';

var Primitives = function() {}

Primitives.prototype.addPrimsTo = function(primTable) {
    // Math primitives
    primTable['+']        = function(b) { return interp.numarg(b, 0) + interp.numarg(b, 1); };
    primTable['-']        = function(b) { return interp.numarg(b, 0) - interp.numarg(b, 1); };
    primTable['*']        = function(b) { return interp.numarg(b, 0) * interp.numarg(b, 1); };
    primTable['/']        = function(b) { return interp.numarg(b, 0) / interp.numarg(b, 1); };
    primTable['%']        = this.primModulo;
    primTable['randomFrom:to:'] = this.primRandom;
    primTable['<']        = function(b) { return (interp.numarg(b, 0) < interp.numarg(b, 1)); };
    primTable['=']        = function(b) { return (interp.arg(b, 0) == interp.arg(b, 1)); };
    primTable['>']        = function(b) { return (interp.numarg(b, 0) > interp.numarg(b, 1)); };
    primTable['&']        = function(b) { return interp.boolarg(b, 0) && interp.boolarg(b, 1); };
    primTable['|']        = function(b) { return interp.boolarg(b, 0) || interp.boolarg(b, 1); };
    primTable['not']      = function(b) { return !interp.boolarg(b, 0); };
    primTable['abs']      = function(b) { return Math.abs(interp.numarg(b, 0)); };
    primTable['sqrt']     = function(b) { return Math.sqrt(interp.numarg(b, 0)); };

    primTable['\\\\']               = this.primModulo;
    primTable['rounded']            = function(b) { return Math.round(interp.numarg(b, 0)); };
    primTable['computeFunction:of:'] = this.primMathFunction;

    // String primitives
    primTable['concatenate:with:']  = function(b) { return '' + interp.arg(b, 0) + interp.arg(b, 1); };
    primTable['letter:of:']         = this.primLetterOf;
    primTable['stringLength:']      = function(b) { return interp.arg(b, 0).length; };

    new VarListPrims().addPrimsTo(primTable);
    new MotionAndPenPrims().addPrimsTo(primTable);
    new LooksPrims().addPrimsTo(primTable);
    new SensingPrims().addPrimsTo(primTable);
    new SoundPrims().addPrimsTo(primTable);
}

Primitives.prototype.primRandom = function(b) {
    var n1 = interp.numarg(b, 0);
    var n2 = interp.numarg(b, 1);
    var low = n1 <= n2 ? n1 : n2;
    var hi = n1 <= n2 ? n2 : n1;
    if (low == hi) return low;
    // if both low and hi are ints, truncate the result to an int
    if (Math.floor(low) == low && Math.floor(hi) == hi) {
        return low + Math.floor(Math.random() * (hi + 1 - low));
    }
    return Math.random() * (hi - low) + low;
}

Primitives.prototype.primLetterOf = function(b) {
    var s = interp.arg(b, 1);
    var i = interp.numarg(b, 0) - 1;
    if (i < 0 || i >= s.length) return '';
    return s.charAt(i);
}

Primitives.prototype.primModulo = function(b) {
    var dividend = interp.numarg(b, 1);
    var n = interp.numarg(b, 0) % dividend;
    if (n / dividend < 0) n += dividend;
    return n;
}

Primitives.prototype.primMathFunction = function(b) {
    var op = interp.arg(b, 0);
    var n = interp.numarg(b, 1);
    switch(op) {
        case 'abs': return Math.abs(n);
        case 'sqrt': return Math.sqrt(n);
        case 'sin': return Math.sin(n * Math.PI / 180);
        case 'cos': return Math.cos(n * Math.PI / 180);
        case 'tan': return Math.tan(n * Math.PI / 180);
        case 'asin': return Math.asin(n) * 180 / Math.PI;
        case 'acos': return Math.acos(n) * 180 / Math.PI;
        case 'atan': return Math.atan(n) * 180 / Math.PI;
        case 'ln': return Math.log(n);
        case 'log': return Math.log(n) / Math.LN10;
        case 'e ^': return Math.exp(n);
        case '10 ^': return Math.exp(n * Math.LN10);
        case 'floor': return Math.floor(n);
        case 'ceiling': return Math.ceil(n);
    }
    return 0;
}


/*MotionAndPenPrims.js*/

'use strict';

var MotionAndPenPrims = function() {};

MotionAndPenPrims.prototype.addPrimsTo = function(primTable) {
    primTable['forward:']           = this.primMove;
    primTable['turnLeft:']          = this.primTurnLeft;
    primTable['turnRight:']         = this.primTurnRight;
    primTable['heading:']           = this.primSetDirection;
    primTable['pointTowards:']      = this.primPointTowards;
    primTable['gotoX:y:']           = this.primGoTo;
    primTable['gotoSpriteOrMouse:']  = this.primGoToSpriteOrMouse;
    primTable['glideSecs:toX:y:elapsed:from:'] = this.primGlide;

    primTable['changeXposBy:']      = this.primChangeX;
    primTable['xpos:']              = this.primSetX;
    primTable['changeYposBy:']      = this.primChangeY;
    primTable['ypos:']              = this.primSetY;

    primTable['bounceOffEdge']      = this.primBounceOffEdge;
    primTable['setRotationStyle']   = this.primSetRotationStyle;

    primTable['xpos']               = this.primXPosition;
    primTable['ypos']               = this.primYPosition;
    primTable['heading']            = this.primDirection;

    primTable['clearPenTrails']     = this.primClear;
    primTable['putPenDown']         = this.primPenDown;
    primTable['putPenUp']           = this.primPenUp;
    primTable['penColor:']          = this.primSetPenColor;
    primTable['setPenHueTo:']       = this.primSetPenHue;
    primTable['changePenHueBy:']    = this.primChangePenHue;
    primTable['setPenShadeTo:']     = this.primSetPenShade;
    primTable['changePenShadeBy:']  = this.primChangePenShade;
    primTable['penSize:']           = this.primSetPenSize;
    primTable['changePenSizeBy:']   = this.primChangePenSize;

    primTable['stampCostume']       = this.primStamp;
    primTable['stampTransparent']   = this.primStampTransparent;
};

MotionAndPenPrims.prototype.primMove = function(b) {
    var s = interp.targetSprite();
    var radians = (90 - s.direction) * Math.PI / 180;
    var d = interp.numarg(b, 0);

    moveSpriteTo(s, s.scratchX + d * Math.cos(radians), s.scratchY + d * Math.sin(radians));
    if (s.visible) interp.redraw();
};

MotionAndPenPrims.prototype.primTurnLeft = function(b) {
    var s = interp.targetSprite();
    var d = s.direction - interp.numarg(b, 0);
    s.setDirection(d);
    if (s.visible) interp.redraw();
};

MotionAndPenPrims.prototype.primTurnRight = function(b) {
    var s = interp.targetSprite();
    var d = s.direction + interp.numarg(b, 0);
    s.setDirection(d);
    if (s.visible) interp.redraw();
};

MotionAndPenPrims.prototype.primSetDirection = function(b) {
    var s = interp.targetSprite();
    s.setDirection(interp.numarg(b, 0));
    if (s.visible) interp.redraw();
};

MotionAndPenPrims.prototype.primPointTowards = function(b) {
    var s = interp.targetSprite();
    var p = mouseOrSpritePosition(interp.arg(b, 0));
    if (s == null || p == null) return;
    var dx = p.x - s.scratchX;
    var dy = p.y - s.scratchY;
    var angle = 90 - Math.atan2(dy, dx) * 180 / Math.PI;
    s.setDirection(angle);
    if (s.visible) interp.redraw();
};

MotionAndPenPrims.prototype.primGoTo = function(b) {
    var s = interp.targetSprite();
    if (s != null) moveSpriteTo(s, interp.numarg(b, 0), interp.numarg(b, 1));
};

MotionAndPenPrims.prototype.primGoToSpriteOrMouse = function(b) {
    var s = interp.targetSprite();
    var p = mouseOrSpritePosition(interp.arg(b, 0));
    if (s == null || p == null) return;
    moveSpriteTo(s, p.x, p.y);
};

MotionAndPenPrims.prototype.primGlide = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    if (interp.activeThread.firstTime) {
        var secs = interp.numarg(b, 0);
        var destX = interp.numarg(b, 1);
        var destY = interp.numarg(b, 2);
        if (secs <= 0) {
            moveSpriteTo(s, destX, destY);
            return;
        }
        // record state: [0]start msecs, [1]duration, [2]startX, [3]startY, [4]endX, [5]endY
        interp.activeThread.tmpObj = [interp.currentMSecs, 1000 * secs, s.scratchX, s.scratchY, destX, destY];
        interp.startTimer(secs);
    } else {
        var state = interp.activeThread.tmpObj;
        if (!interp.checkTimer()) {
            // in progress: move to intermediate position along path
            var frac = (interp.currentMSecs - state[0]) / state[1];
            var newX = state[2] + frac * (state[4] - state[2]);
            var newY = state[3] + frac * (state[5] - state[3]);
            moveSpriteTo(s, newX, newY);
        } else {
            // finished: move to final position and clear state
            moveSpriteTo(s, state[4], state[5]);
            interp.activeThread.tmpObj = null;
        }
    }
};

MotionAndPenPrims.prototype.primChangeX = function(b) {
    var s = interp.targetSprite();
    if (s != null) moveSpriteTo(s, s.scratchX + interp.numarg(b, 0), s.scratchY);
};

MotionAndPenPrims.prototype.primSetX = function(b) {
    var s = interp.targetSprite();
    if (s != null) moveSpriteTo(s, interp.numarg(b, 0), s.scratchY);
};

MotionAndPenPrims.prototype.primChangeY = function(b) {
    var s = interp.targetSprite();
    if (s != null) moveSpriteTo(s, s.scratchX, s.scratchY + interp.numarg(b, 0));
};

MotionAndPenPrims.prototype.primSetY = function(b) {
    var s = interp.targetSprite();
    if (s != null) moveSpriteTo(s, s.scratchX, interp.numarg(b, 0));
};

MotionAndPenPrims.prototype.primBounceOffEdge = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    if (!turnAwayFromEdge(s)) return;
    ensureOnStageOnBounce(s);
    if (s.visible) interp.redraw();
};

MotionAndPenPrims.prototype.primSetRotationStyle = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    var request = interp.arg(b, 0);
    var rotationStyle = 'normal';
    if (request == 'all around') rotationStyle = 'normal';
    else if (request == 'left-right') rotationStyle = 'leftRight';
    else if (request == 'none') rotationStyle = 'none';
    s.setRotationStyle(rotationStyle);
};

MotionAndPenPrims.prototype.primXPosition = function(b) {
    var s = interp.targetSprite();
    return s != null ? s.scratchX : 0;
};

MotionAndPenPrims.prototype.primYPosition = function(b) {
    var s = interp.targetSprite();
    return s != null ? s.scratchY : 0;
};

MotionAndPenPrims.prototype.primDirection = function(b) {
    var s = interp.targetSprite();
    return s != null ? s.direction : 0;
};

MotionAndPenPrims.prototype.primClear = function(b) {
    runtime.stage.clearPenStrokes();
    interp.redraw();
};

MotionAndPenPrims.prototype.primPenDown = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.penIsDown = true;
    stroke(s, s.scratchX, s.scratchY, s.scratchX + 0.2, s.scratchY + 0.2);
    interp.redraw();
};

MotionAndPenPrims.prototype.primPenUp = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.penIsDown = false;
};

MotionAndPenPrims.prototype.primSetPenColor = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.setPenColor(interp.numarg(b, 0));
};

MotionAndPenPrims.prototype.primSetPenHue = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.setPenHue(interp.numarg(b, 0));
};

MotionAndPenPrims.prototype.primChangePenHue = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.setPenHue(s.penHue + interp.numarg(b, 0));
};

MotionAndPenPrims.prototype.primSetPenShade = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.setPenShade(interp.numarg(b, 0));
};

MotionAndPenPrims.prototype.primChangePenShade = function(b) {
    var s = interp.targetSprite();
    if (s != null) s.setPenShade(s.penShade + interp.numarg(b, 0));
};

MotionAndPenPrims.prototype.primSetPenSize = function(b) {
    var s = interp.targetSprite();
    var w = Math.max(0, Math.min(interp.numarg(b, 0), 100));
    if (s != null) s.penWidth = w;
};

MotionAndPenPrims.prototype.primChangePenSize = function(b) {
    var s = interp.targetSprite();
    var w = Math.max(0, Math.min(s.penWidth + interp.numarg(b, 0), 100));
    if (s != null) s.penWidth = w;
};

MotionAndPenPrims.prototype.primStamp = function(b) {
    var s = interp.targetSprite();
    s.stamp(runtime.stage.lineCache, 100);
};

MotionAndPenPrims.prototype.primStampTransparent = function(b) {
    var s = interp.targetSprite();
    var transparency = Math.max(0, Math.min(interp.numarg(b, 0), 100));
    var alpha = 100 - transparency;
    s.stamp(runtime.stage.lineCache, alpha);
};

// Helpers
var stroke = function(s, oldX, oldY, newX, newY) {
    runtime.stage.stroke([oldX, oldY], [newX, newY], s.penWidth, s.penColorCache);
    interp.redraw();
};

var mouseOrSpritePosition = function(arg) {
    if (arg == '_mouse_') {
        var w = runtime.stage;
        return new Point(runtime.mousePos[0], runtime.mousePos[1]);
    } else {
        var s = runtime.spriteNamed(arg);
        if (s == null) return null;
        return new Point(s.scratchX, s.scratchY);
    }
    return null;
};

var moveSpriteTo = function(s, newX, newY) {
    var oldX = s.scratchX;
    var oldY = s.scratchY;
    s.setXY(newX, newY);
    s.keepOnStage();
    if (s.penIsDown) stroke(s, oldX, oldY, s.scratchX, s.scratchY);
    if (s.penIsDown || s.visible) interp.redraw();
};

var turnAwayFromEdge = function(s) {
    // turn away from the nearest edge if it's close enough; otherwise do nothing
    // Note: comparisions are in the stage coordinates, with origin (0, 0)
    // use bounding rect of the sprite to account for costume rotation and scale
    var r = s.getRect();
    // measure distance to edges
    var d1 = Math.max(0, r.left);
    var d2 = Math.max(0, r.top);
    var d3 = Math.max(0, 480 - r.right);
    var d4 = Math.max(0, 360 - r.bottom);
    // find the nearest edge
    var e = 0, minDist = 100000;
    if (d1 < minDist) { minDist = d1; e = 1; }
    if (d2 < minDist) { minDist = d2; e = 2; }
    if (d3 < minDist) { minDist = d3; e = 3; }
    if (d4 < minDist) { minDist = d4; e = 4; }
    if (minDist > 0) return false;  // not touching to any edge
    // point away from nearest edge
    var radians = (90 - s.direction) * Math.PI / 180;
    var dx = Math.cos(radians);
    var dy = -Math.sin(radians);
    if (e == 1) { dx = Math.max(0.2, Math.abs(dx)); }
    if (e == 2) { dy = Math.max(0.2, Math.abs(dy)); }
    if (e == 3) { dx = 0 - Math.max(0.2, Math.abs(dx)); }
    if (e == 4) { dy = 0 - Math.max(0.2, Math.abs(dy)); }
    var newDir = Math.atan2(dy, dx) * 180 / Math.PI + 90;
    s.direction = newDir;
    return true;
};

var ensureOnStageOnBounce = function(s) {
    var r = s.getRect();
    if (r.left < 0) moveSpriteTo(s, s.scratchX - r.left, s.scratchY);
    if (r.top < 0) moveSpriteTo(s, s.scratchX, s.scratchY + r.top);
    if (r.right > 480) {
        moveSpriteTo(s, s.scratchX - (r.right - 480), s.scratchY);
    }
    if (r.bottom > 360) {
        moveSpriteTo(s, s.scratchX, s.scratchY + (r.bottom - 360));
    }
};

/*LooksPrims.js*/

'use strict';

var LooksPrims = function() {};

LooksPrims.prototype.addPrimsTo = function(primTable) {
    primTable['show']               = this.primShow;
    primTable['hide']               = this.primHide;

    primTable['nextCostume']        = this.primNextCostume;
    primTable['lookLike:']          = this.primShowCostume;
    primTable['costumeIndex']       = this.primCostumeNum;

    primTable['nextScene']     = this.primNextCostume;
    primTable['showBackground:']    = this.primShowCostume;
    primTable['backgroundIndex']    = this.primCostumeNum;

    primTable['startScene']         = this.primStartScene;
    primTable['backgroundIndex']    = this.primCostumeNum;

    primTable['changeSizeBy:']      = this.primChangeSize;
    primTable['setSizeTo:']         = this.primSetSize;
    primTable['scale']              = this.primSize;

    primTable['comeToFront']        = this.primGoFront;
    primTable['goBackByLayers:']    = this.primGoBack;

    primTable['changeGraphicEffect:by:'] = this.primChangeEffect;
    primTable['setGraphicEffect:to:']    = this.primSetEffect;
    primTable['filterReset']             = this.primClearEffects;

    primTable['say:'] = function(b) { showBubble(b, 'say'); };
    primTable['say:duration:elapsed:from:'] = function(b) { showBubbleAndWait(b, 'say'); };
    primTable['think:'] = function(b) { showBubble(b, 'think'); };
    primTable['think:duration:elapsed:from:'] = function(b) { showBubbleAndWait(b, 'think'); };
};

LooksPrims.prototype.primShow = function(b) {
    interp.targetSprite().setVisible(true);
    interp.redraw();
};

LooksPrims.prototype.primHide = function(b) {
    interp.targetSprite().setVisible(false);
    interp.redraw();
};

LooksPrims.prototype.primNextCostume = function(b) {
    interp.targetSprite().showCostume(interp.targetSprite().currentCostumeIndex + 1);
    interp.redraw();
};

LooksPrims.prototype.primShowCostume = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    var arg = interp.arg(b, 0);
    if (typeof(arg) == 'number') {
        s.showCostume(arg - 1);
    } else {
        if ((arg == 'CAMERA') || (arg == 'CAMERA - MIRROR')) {
            s.showCostumeNamed(arg);
            return;
        }
        var i = s.indexOfCostumeNamed(arg);
        if (i >= 0) {
            s.showCostume(i);
        } else {
            var n = parseInt(arg, 10);
            if (n === n) { // if n is not NaN
                s.showCostume(n - 1);
            } else {
                return;  // arg did not match a costume name nor is a valid number
            }
        }
    }
    if (s.visible) interp.redraw();
};

LooksPrims.prototype.primStartScene = function(b) {
    var s = runtime.stage;
    var arg = interp.arg(b, 0);
    if (typeof(arg) == 'number') {
        s.showCostume(arg - 1);
    } else {
        if ((arg == 'CAMERA') || (arg == 'CAMERA - MIRROR')) {
            s.showCostumeNamed(arg);
            return;
        }
        var i = s.indexOfCostumeNamed(arg);
        if (i >= 0) {
            s.showCostume(i);
        } else {
            var n = parseInt(arg, 10);
            if (n === n) { // fast !isNaN check
                s.showCostume(n - 1);
            } else {
                return;  // arg did not match a costume name nor is a valid number
            }
        }
    }
    if (s.visible) interp.redraw();
};

LooksPrims.prototype.primCostumeNum = function(b) {
    var s = interp.targetSprite();
    return s == null ? 1 : s.currentCostumeIndex + 1;
};

LooksPrims.prototype.primChangeSize = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    s.setSize(s.getSize() + interp.numarg(b, 0));
    if (s.visible) interp.redraw();
};

LooksPrims.prototype.primSetSize = function(b) {
    var s = interp.targetSprite();
    if (s == null) return;
    s.setSize(interp.numarg(b, 0));
    if (s.visible) interp.redraw();
};

LooksPrims.prototype.primSize = function(b) {
    var s = interp.targetSprite();
    if (s == null) return 100;
    return s.getSize();
};

LooksPrims.prototype.primGoFront = function(b) {
    var s = interp.targetSprite();
    runtime.reassignZ(s, null);
    if (s.visible) interp.redraw();
};

LooksPrims.prototype.primGoBack = function(b) {
    var s = interp.targetSprite();
    runtime.reassignZ(s, interp.numarg(b, 0));
    if(s.visible) interp.redraw();
};

LooksPrims.prototype.primChangeEffect = function(b) {
    var s = interp.targetSprite();
    s.filters[interp.arg(b, 0)] += interp.numarg(b, 1);
    s.updateFilters();
};

LooksPrims.prototype.primSetEffect = function(b) {
    var s = interp.targetSprite();
    s.filters[interp.arg(b, 0)] = interp.numarg(b, 1);
    s.updateFilters();
};

LooksPrims.prototype.primClearEffects = function(b) {
    var s = interp.targetSprite();
    s.resetFilters();
    s.updateFilters();
};

var showBubble = function(b, type) {
    var s = interp.targetSprite();
    if (s !== null) s.showBubble(interp.arg(b, 0), type);
};

var showBubbleAndWait = function(b, type) {
    var s = interp.targetSprite();
    if (s === null) return;
    if (interp.activeThread.firstTime) {
        var text = interp.arg(b, 0);
        var secs = interp.numarg(b, 1);
        s.showBubble(text, type);
        if (s.visible) interp.redraw();
        interp.startTimer(secs);
    } else {
        if (interp.checkTimer()) s.hideBubble();
    }
};


/*WAVFile.js*/

var WAVFile = function() {};

WAVFile.decode = function(waveData) {
    // Decode the given WAV file data and return an Object with the format and sample data.
    var result = {};

    var data = new OffsetBuffer(waveData);

    // read WAVE File Header
    if (data.readString(4) != 'RIFF') { console.log("WAVFile:  bad file header"); return; }
    var totalSize = data.readInt();
    if (data.getLength() != (totalSize + 8)) console.log("WAVFile: bad RIFF size; ignoring");
    if (data.readString(4) != 'WAVE') { console.log("WAVFile: not a WAVE file"); return; }

    // read format chunk
    var formatChunk = WAVFile.extractChunk('fmt ', data);
    if (formatChunk.getLength() < 16) { console.log("WAVFile: format chunk is too small"); return; }

    var encoding = formatChunk.readShort();
    result.encoding = encoding;
    result.channels = formatChunk.readShort();
    result.samplesPerSecond = formatChunk.readInt();
    result.bytesPerSecond = formatChunk.readInt();
    result.blockAlignment = formatChunk.readShort();
    result.bitsPerSample = formatChunk.readShort();

    // get size of data chunk
    var sampleDataStartAndSize = WAVFile.dataChunkStartAndSize(data);
    result.sampleDataStart = sampleDataStartAndSize[0];
    result.sampleDataSize = sampleDataStartAndSize[1];

    // handle various encodings
    if (encoding == 1) {
        if (!((result.bitsPerSample == 8) || (result.bitsPerSample == 16))) {
            console.log("WAVFile: can only handle 8-bit or 16-bit uncompressed PCM data");
            return;
        }
        result.sampleCount = result.sampleDataSize / 2;
    } else if (encoding == 17) {
        if (formatChunk.length < 20) { console.log("WAVFile: adpcm format chunk is too small"); return; }
        if (result.channels != 1) { console.log("WAVFile: adpcm supports only one channel (monophonic)"); return; }
        formatChunk.offset += 2;  // skip extra header byte count
        var samplesPerBlock = formatChunk.readShort();
        result.adpcmBlockSize = ((samplesPerBlock - 1) / 2) + 4; // block size in bytes
        var factChunk = WAVFile.extractChunk('fact', data);
        if ((factChunk != null) && (factChunk.getLength() == 4)) {
            result.sampleCount = factChunk.readInt();
        } else {
            // this should never happen, since there should always be a 'fact' chunk
            // slight over-estimate (doesn't take ADPCM headers into account)
            result.sampleCount = 2 * result.sampleDataSize;
        }
    } else {
        console.log("WAVFile: unknown encoding " + encoding);
        return;
    }
    return result;
};

WAVFile.extractChunk = function(desiredType, data) {
    // Return the contents of the first chunk of the given type or an empty OffsetBuffer if it is not found.
    data.offset = 12;
    while (data.bytesAvailable() > 8) {
        var chunkType = data.readString(4);
        var chunkSize = data.readUint();
        if (chunkType == desiredType) {
            if (chunkSize > data.bytesAvailable()) return null;
            var result = new OffsetBuffer(data.readBytes(chunkSize));
            return result;
        } else {
            data.offset += chunkSize;
        }
    }
    return new OffsetBuffer(new ArrayBuffer());
};

WAVFile.dataChunkStartAndSize = function(data) {
    // Return an array with the starting offset and size of the first chunk of the given type.
    data.offset = 12;
    while (data.bytesAvailable() >= 8) {
        var chunkType = data.readString(4);
        var chunkSize = data.readUint();
        if (chunkType == 'data') {
            if (chunkSize > data.bytesAvailable()) return [0, 0]; // bad wave file
            return [data.offset, chunkSize];
        } else {
            data.offset += chunkSize;
        }
    }
    return [0, 0]; // chunk not found; bad wave file
};

/*SoundDecoder.js*/

var SoundDecoder = function(wavFileData) {
    this.scratchSound = null;

    this.soundData = null;
    this.startOffset = 0;
    this.endOffset = 0;
    this.stepSize = 0;
    this.adpcmBlockSize = 0;
    this.bytePosition = 0;
    this.soundChannel = null;
    this.lastBufferTime = 0;

    this.getSample = null;
    this.fraction = 0.0;
    this.thisSample = 0;

    // decoder state
    this.sample = 0;
    this.index = 0;
    this.lastByte = -1; // -1 indicates that there is no saved lastByte

    this.nextSample = 0;

    this.info = null;

    getSample = this.getSample16Uncompressed;
    if (wavFileData != null) {
        var info = WAVFile.decode(wavFileData);
        this.info = info;
        this.startOffset = info.sampleDataStart;
        this.endOffset = this.startOffset + info.sampleDataSize;
        this.soundData = new Uint8Array(wavFileData.slice(this.startOffset, this.endOffset));
        this.stepSize = info.samplesPerSecond / 44100.0;
        if (info.encoding == 17) {
            this.adpcmBlockSize = info.adpcmBlockSize;
            this.getSample = this.getSampleADPCM;
        } else {
            if (info.bitsPerSample == 8) this.getSample = this.getSample8Uncompressed;
            if (info.bitsPerSample == 16) this.getSample = this.getSample16Uncompressed;
        }
    }
};

SoundDecoder.prototype.noteFinished = function() {
    // Called by subclasses to force ending condition to be true in writeSampleData()
    this.bytePosition = this.endOffset;
};

// Used for Notes and Drums - Web Audio API ScriptProcessorNodes use this
// as a callback function to fill the buffers with sample data.
SoundDecoder.prototype.writeSampleData = function(evt) {
    var i = 0;
    var output = evt.outputBuffer.getChannelData(0);
    //this.updateVolume();
    for (i = 0; i < output.length; i++) {
        var n = this.interpolatedSample();
        output[i] = n;
    }
};

// For pre-caching the samples of WAV sounds
// Return a full list of samples generated by the decoder.
SoundDecoder.prototype.getAllSamples = function() {
    var samples = [], smp = 0;
    smp = this.interpolatedSample();
    while (smp != null) {
        samples.push(smp);
        smp = this.interpolatedSample();
    }
    return samples;
};

// Provide the next sample for the buffer
SoundDecoder.prototype.interpolatedSample = function() {
    this.fraction += this.stepSize;
    while (this.fraction >= 1.0) {
        this.thisSample = this.nextSample;
        this.nextSample = this.getSample();
        this.fraction -= 1.0;
    }
    if (this.nextSample == null) { return null; }
    var out = this.fraction == 0 ? this.thisSample : this.thisSample + this.fraction * (this.nextSample - this.thisSample);
    return out / 32768.0;
};

// 16-bit samples, big-endian
SoundDecoder.prototype.getSample16Uncompressed = function() {
    var result = 0;
    if (this.bytePosition <= (this.info.sampleDataSize - 2)) {
        result = (this.soundData[this.bytePosition + 1] << 8) + this.soundData[this.bytePosition];
        if (result > 32767) result -= 65536;
        this.bytePosition += 2;
    } else {
        this.bytePosition = this.endOffset;
        result = null;
    }
    return result;
};

// 8-bit samples, uncompressed
SoundDecoder.prototype.getSample8Uncompressed = function() {
    if (this.bytePosition >= this.info.sampleDataSize) return null;
    return (this.soundData[this.bytePosition++] - 128) << 8;
};

/*SoundDecoder.prototype.updateVolume = function() {
    if (this.client == null) {
        this.volume = 1.0;
        return;
    }
    if (this.client.volume == this.lastClientVolume) return; // optimization
    this.volume = Math.max(0.0, Math.min(this.client.volume / 100.0, 1.0));
    this.lastClientVolume = this.client.volume;
}*/

// Decoder for IMA ADPCM compressed sounds
SoundDecoder.indexTable = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];

SoundDecoder.stepTable = [
    7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
    50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230,
    253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963,
    1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327,
    3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487,
    12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
];

SoundDecoder.prototype.getSampleADPCM = function() {
    // Decompress sample data using the IMA ADPCM algorithm.
    // Note: Handles only one channel, 4-bits/sample.
    var step = 0, code = 0, delta = 0;

    if (this.bytePosition % this.adpcmBlockSize == 0 && this.lastByte < 0) { // read block header
        if (this.bytePosition > this.info.sampleDataSize - 4) return null;
        this.sample = (this.soundData[this.bytePosition + 1] << 8) + this.soundData[this.bytePosition];
        if (this.sample > 32767) this.sample -= 65536;
        this.index = this.soundData[this.bytePosition + 2];
        this.bytePosition += 4;
        if (this.index > 88) this.index = 88;
        this.lastByte = -1;
        return this.sample;
    } else {
        // read 4-bit code and compute delta
        if (this.lastByte < 0) {
            if (this.bytePosition >= this.info.sampleDataSize) return null;
            this.lastByte = this.soundData[this.bytePosition++];
            code = this.lastByte & 0xF;
        } else {
            code = (this.lastByte >> 4) & 0xF;
            this.lastByte = -1;
        }
        step = SoundDecoder.stepTable[this.index];
        delta = 0;
        if (code & 4) delta += step;
        if (code & 2) delta += step >> 1;
        if (code & 1) delta += step >> 2;
        delta += step >> 3;
        // compute next index
        this.index += SoundDecoder.indexTable[code];
        if (this.index > 88) this.index = 88;
        if (this.index < 0) this.index = 0;
        // compute and output sample
        this.sample += code & 8 ? -delta : delta;
        if (this.sample > 32767) this.sample = 32767;
        if (this.sample < -32768) this.sample = -32768;
        return this.sample;
    }
}


/*SoundBank.js*/

var SoundBank = function() {};

// -----------------------------
// Scratch 2.0 Instrument Definitions
//------------------------------

// Each instrument is an array of one or more key-span entries of the following form:
//
//   top key of key span, sampleName, midiKey, loopStart, loopEnd, [attack, hold, decay]
//
// The loop points are -1 if the sound is unlooped (e.g. Marimba).
// The three-element envelop array may be omitted if the instrument has no envelope.
SoundBank.instruments = [
    [
        [38, 'AcousticPiano_As3', 58, 10266, 17053, [0, 100, 22]],
        [44, 'AcousticPiano_C4', 60, 13968, 18975, [0, 100, 20]],
        [51, 'AcousticPiano_G4', 67, 12200, 12370, [0, 80, 18]],
        [62, 'AcousticPiano_C6', 84, 13042, 13276, [0, 80, 16]],
        [70, 'AcousticPiano_F5', 77, 12425, 12965, [0, 40, 14]],
        [77, 'AcousticPiano_Ds6', 87, 12368, 12869, [0, 20, 10]],
        [85, 'AcousticPiano_Ds6', 87, 12368, 12869, [0, 0, 8]],
        [90, 'AcousticPiano_Ds6', 87, 12368, 12869, [0, 0, 6]],
        [96, 'AcousticPiano_D7', 98, 7454, 7606, [0, 0, 3]],
        [128, 'AcousticPiano_D7', 98, 7454, 7606, [0, 0, 2]]
    ],
    [
        [48, 'ElectricPiano_C2', 36, 15338, 17360, [0, 80, 10]],
        [74, 'ElectricPiano_C4', 60, 11426, 12016, [0, 40, 8]],
        [128, 'ElectricPiano_C4', 60, 11426, 12016, [0, 0, 6]]
    ],
    [
        [128, 'Organ_G2', 43, 1306, 3330]
    ],
    [
        [40, 'AcousticGuitar_F3', 53, 36665, 36791, [0, 0, 15]],
        [56, 'AcousticGuitar_F3', 53, 36665, 36791, [0, 0, 13.5]],
        [60, 'AcousticGuitar_F3', 53, 36665, 36791, [0, 0, 12]],
        [67, 'AcousticGuitar_F3', 53, 36665, 36791, [0, 0, 8.5]],
        [72, 'AcousticGuitar_F3', 53, 36665, 36791, [0, 0, 7]],
        [83, 'AcousticGuitar_F3', 53, 36665, 36791, [0, 0, 5.5]],
        [128, 'AcousticGuitar_F3', 53, 36665, 36791, [0, 0, 4.5]]
    ],
    [
        [40, 'ElectricGuitar_F3', 53, 34692, 34945, [0, 0, 15]],
        [56, 'ElectricGuitar_F3', 53, 34692, 34945, [0, 0, 13.5]],
        [60, 'ElectricGuitar_F3', 53, 34692, 34945, [0, 0, 12]],
        [67, 'ElectricGuitar_F3', 53, 34692, 34945, [0, 0, 8.5]],
        [72, 'ElectricGuitar_F3', 53, 34692, 34945, [0, 0, 7]],
        [83, 'ElectricGuitar_F3', 53, 34692, 34945, [0, 0, 5.5]],
        [128, 'ElectricGuitar_F3', 53, 34692, 34945, [0, 0, 4.5]]
    ],
    [
        [34, 'ElectricBass_G1', 31, 41912, 42363, [0, 0, 17]],
        [48, 'ElectricBass_G1', 31, 41912, 42363, [0, 0, 14]],
        [64, 'ElectricBass_G1', 31, 41912, 42363, [0, 0, 12]],
        [128, 'ElectricBass_G1', 31, 41912, 42363, [0, 0, 10]]
    ],
    [
        [38, 'Pizz_G2', 43, 8554, 8782, [0, 0, 5]],
        [45, 'Pizz_G2', 43, 8554, 8782, [0, 12, 4]],
        [56, 'Pizz_A3', 57, 11460, 11659, [0, 0, 4]],
        [64, 'Pizz_A3', 57, 11460, 11659, [0, 0, 3.2]],
        [72, 'Pizz_E4', 64, 17525, 17592, [0, 0, 2.8]],
        [80, 'Pizz_E4', 64, 17525, 17592, [0, 0, 2.2]],
        [128, 'Pizz_E4', 64, 17525, 17592, [0, 0, 1.5]]
    ],
    [
        [41, 'Cello_C2', 36, 8548, 8885],
        [52, 'Cello_As2', 46, 7465, 7845],
        [62, 'Violin_D4', 62, 10608, 11360],
        [75, 'Violin_A4', 69, 3111, 3314, [70, 0, 0]],
        [128, 'Violin_E5', 76, 2383, 2484]
    ],
    [
        [30, 'BassTrombone_A2_3', 45, 1357, 2360],
        [40, 'BassTrombone_A2_2', 45, 1893, 2896],
        [55, 'Trombone_B3', 59, 2646, 3897],
        [88, 'Trombone_B3', 59, 2646, 3897, [50, 0, 0]],
        [128, 'Trumpet_E5', 76, 2884, 3152]
    ],
    [
        [128, 'Clarinet_C4', 60, 14540, 15468]
    ],
    [
        [40, 'TenorSax_C3', 48, 8939, 10794],
        [50, 'TenorSax_C3', 48, 8939, 10794, [20, 0, 0]],
        [59, 'TenorSax_C3', 48, 8939, 10794, [40, 0, 0]],
        [67, 'AltoSax_A3', 57, 8546, 9049],
        [75, 'AltoSax_A3', 57, 8546, 9049, [20, 0, 0]],
        [80, 'AltoSax_A3', 57, 8546, 9049, [20, 0, 0]],
        [128, 'AltoSax_C6', 84, 1258, 1848]
    ],
    [
        [61, 'Flute_B5_2', 83, 1859, 2259],
        [128, 'Flute_B5_1', 83, 2418, 2818]
    ],
    [
        [128, 'WoodenFlute_C5', 72, 11426, 15724]
    ],
    [
        [57, 'Bassoon_C3', 48, 2428, 4284],
        [67, 'Bassoon_C3', 48, 2428, 4284, [40, 0, 0]],
        [76, 'Bassoon_C3', 48, 2428, 4284, [80, 0, 0]],
        [84, 'EnglishHorn_F3', 53, 7538, 8930, [40, 0, 0]],
        [128, 'EnglishHorn_D4', 62, 4857, 5231]
    ],
    [
        [39, 'Choir_F3', 53, 14007, 41281],
        [50, 'Choir_F3', 53, 14007, 41281, [40, 0, 0]],
        [61, 'Choir_F3', 53, 14007, 41281, [60, 0, 0]],
        [72, 'Choir_F4', 65, 16351, 46436],
        [128, 'Choir_F5', 77, 18440, 45391]
    ],
    [
        [38, 'Vibraphone_C3', 48, 6202, 6370, [0, 100, 8]],
        [48, 'Vibraphone_C3', 48, 6202, 6370, [0, 100, 7.5]],
        [59, 'Vibraphone_C3', 48, 6202, 6370, [0, 60, 7]],
        [70, 'Vibraphone_C3', 48, 6202, 6370, [0, 40, 6]],
        [78, 'Vibraphone_C3', 48, 6202, 6370, [0, 20, 5]],
        [86, 'Vibraphone_C3', 48, 6202, 6370, [0, 0, 4]],
        [128, 'Vibraphone_C3', 48, 6202, 6370, [0, 0, 3]]
    ],
    [
        [128, 'MusicBox_C4', 60, 14278, 14700, [0, 0, 2]]
    ],
    [
        [128, 'SteelDrum_D5', 74.4, -1, -1, [0, 0, 2]]
    ],
    [
        [128, 'Marimba_C4', 60, -1, -1]
    ],
    [
        [80, 'SynthLead_C4', 60, 135, 1400],
        [128, 'SynthLead_C6', 84, 124, 356]
    ],
    [
        [38, 'SynthPad_A3', 57, 4212, 88017, [50, 0, 0]],
        [50, 'SynthPad_A3', 57, 4212, 88017, [80, 0, 0]],
        [62, 'SynthPad_A3', 57, 4212, 88017, [110, 0, 0]],
        [74, 'SynthPad_A3', 57, 4212, 88017, [150, 0, 0]],
        [86, 'SynthPad_A3', 57, 4212, 88017, [200, 0, 0]],
        [128, 'SynthPad_C6', 84, 2575, 9202]
    ]
];

// -----------------------------
// Scratch 2.0 Drum Definitions
//------------------------------

// Each drum entry is an array of of the form:
//
//   sampleName, pitchAdjust, [loopStart, loopEnd, decay]
//
// pitchAdjust (pitch shift in semitones) adjusts the original pitch.
// The loop points and decay parameter may be omitted if the drum is unlooped.
// (A few drums are looped to create several different pitched drums from one sample.)
SoundBank.drums = [
    ['SnareDrum', 0],
    ['Tom', 0],
    ['SideStick', 0],
    ['Crash', -7],
    ['HiHatOpen', -8],
    ['HiHatClosed', 0],
    ['Tambourine', 0],
    ['Clap', 0],
    ['Claves', 0],
    ['WoodBlock', -4],
    ['Cowbell', 0],
    ['Triangle', -6, 16843, 17255, 2],
    ['Bongo', 2],
    ['Conga', -7, 4247, 4499, 2], // jhm decay
    ['Cabasa', 0],
    ['GuiroLong', 0],
    ['Vibraslap', -6],
    ['Cuica', -5],
];

SoundBank.getNotePlayer = function(instNum, midiKey) {
    // Return a NotePlayer for the given Scratch 2.0 instrument number (1..21)
    // and MIDI key (0..127). If the instrument is out of range, use 1.
    var r = SoundBank.getNoteRecord(instNum - 1, midiKey);
    var env = r.length > 5 ? r[5] : null;
    return new NotePlayer(Instr.samples[r[1]], SoundBank.pitchForKey(r[2]), r[3], r[4], env);
};

SoundBank.getNoteRecord = function(instNum, midiKey) {
    // Get a note record for the given instrument number.
    if (instNum < 0 || instNum >= SoundBank.instruments.length) instNum = 0;
    var keyRanges = SoundBank.instruments[instNum];
    for (var r = 0; r < keyRanges.length; r++) {
        var topOfKeyRange = keyRanges[r][0];
        if (midiKey <= topOfKeyRange) return keyRanges[r];
    }
    return keyRanges[keyRanges.length - 1]; // return the note record for the top key range.
};

SoundBank.pitchForKey = function(midiKey) {
    return 440 * Math.pow(2, (midiKey - 69) / 12); // midi key 69 is A=440 Hz
};

SoundBank.getDrumPlayer = function(drumNum, secs) {
    // Return a NotePlayer for the given drum number.
    var entry = SoundBank.drums[drumNum - 1];
    if (entry == null) entry = SoundBank.drums[2];
    var loopStart = -1, loopEnd = -1, env = null;
    if (entry.length >= 4) {
        loopStart = entry[2];
        loopEnd = entry[3];
    }
    if (entry.length >= 5) env = [0, 0, entry[4]];
    var player = new NotePlayer(Instr.samples[entry[0]], SoundBank.pitchForKey(60), loopStart, loopEnd, env);
    player.setNoteAndDuration(60 + entry[1], 0);
    return player;
};

/*NotePlayer.js*/

var NotePlayer = function(wavFileData, originalPitch, loopStart, loopEnd, env) {
    this.originalPitch = originalPitch || null;
    this.index = 0;
    this.samplesRemaining = 0; // determines note duration

    // Looping
    this.isLooped = false;
    this.loopPoint = 0; // final sample in loop
    this.loopLength = 0;

    // Volume Envelope
    this.envelopeValue = 1;
    this.samplesSinceStart = 0;
    this.attackEnd = 0;
    this.attackRate = 0;
    this.holdEnd = 0;
    this.decayRate = 1;

    if (wavFileData == null) wavFileData = new ArrayBuffer();

    var stepSize = 0.5; // default - no pitch shift
    var startOffset = 0;
    this.endOffset = wavFileData.byteLength / 2; // end of sample data
    var getSample = function() { return 0; } // called once at startup time
    this.soundData = new Uint8Array(wavFileData);

    if ((loopStart >= 0) && (loopStart < this.endOffset)) {
        this.isLooped = true;
        this.loopPoint = loopStart;
        if ((loopEnd > 0) && (loopEnd <= this.endOffset)) this.endOffset = loopEnd;
        this.loopLength = this.endOffset - this.loopPoint;

        // Compute the original pitch more exactly from the loop length:
        var oneCycle = 22050 / this.originalPitch;
        var cycles = Math.round(this.loopLength / oneCycle);
        this.originalPitch = 22050 / (this.loopLength / cycles);
    }
    if (env) {
        this.attackEnd = env[0] * 44.100;
        if (this.attackEnd > 0) this.attackRate = Math.pow(33000, 1 / this.attackEnd);
        this.holdEnd = this.attackEnd + env[1] * 44.100;
        var decayCount = env[2] * 44100;
        this.decayRate = decayCount == 0 ? 1 : Math.pow(33000, -1 / decayCount);
    }
};

NotePlayer.prototype = Object.create(SoundDecoder.prototype);
NotePlayer.prototype.constructor = NotePlayer;

NotePlayer.prototype.setNoteAndDuration = function(midiKey, secs) {
    midiKey = Math.max(0, Math.min(midiKey, 127));
    var pitch = 440 * Math.pow(2, (midiKey - 69) / 12); // midi key 69 is A (440 Hz)
    this.stepSize = pitch / (2 * this.originalPitch); // adjust for original sampling rate of 22050
    this.setDuration(secs);
};

NotePlayer.prototype.setDuration = function(secs) {
    this.samplesSinceStart = 0;
    this.samplesRemaining = 44100 * secs;
    if (!this.isLooped) this.samplesRemaining = Math.min(this.samplesRemaining, this.endOffset / this.stepSize);
    this.envelopeValue = this.attackEnd > 0 ? 1 / 33000 : 1;
};

NotePlayer.prototype.interpolatedSample = function() {
    if (this.samplesRemaining-- <= 0) { this.noteFinished(); return 0; }
    this.index += this.stepSize;
    while (this.index >= this.endOffset) {
        if (!this.isLooped) return 0;
        this.index -= this.loopLength;
    }
    var i = Math.floor(this.index);
    var frac = this.index - i;
    var curr = this.rawSample(i);
    var next = this.rawSample(i + 1);
    var sample = (curr + frac * (next - curr)) / 100000; // xxx 32000; attenuate...
    if (this.samplesRemaining < 1000) sample *= (this.samplesRemaining / 1000.0); // relaase phease
    this.updateEnvelope();
    return this.envelopeValue * sample;
};

NotePlayer.prototype.rawSample = function(sampleIndex) {
    if (sampleIndex >= this.endOffset) {
        if (!this.isLooped) return 0;
        sampleIndex = this.loopPoint;
    }
    var byteIndex = 2 * sampleIndex;
    var result = (this.soundData[byteIndex + 1] << 8) + this.soundData[byteIndex];
    return result <= 32767 ? result : result - 65536;
};

NotePlayer.prototype.updateEnvelope = function() {
    // Compute envelopeValue for the current sample.
    this.samplesSinceStart++;
    if (this.samplesSinceStart < this.attackEnd) {
        this.envelopeValue *= this.attackRate;
    } else if (this.samplesSinceStart == this.attackEnd) {
        this.envelopeValue = 1;
    } else if (this.samplesSinceStart > this.holdEnd) {
        if (this.decayRate < 1) this.envelopeValue *= this.decayRate;
    }
};

/*Timer.js*/
var Timer = function() {
    var trials = [];
    var last_trial = 0;
    var start_time = 0;
};

Timer.prototype.time = function() {
    return Date.now();
};

Timer.prototype.start = function() {
    start_time = this.time();
};

Timer.prototype.stop = function() {
    end = this.time();
    last_trial = end - start_time;
    trials.push(last_trial);
};

Timer.prototype.count = function() {
    return trials.length;
};

Timer.prototype.average = function() {
    sum = 0;
    for (i = 0; i < this.count(); i++) {
        sum += trials[i];
    }
    return sum / this.count();
};

Timer.prototype.print = function(element) {
    text = "Trial: " + last_trial + "ms" +
           "<br />\nTrials: " + this.count() + ", Avg: " + this.average() + "ms";
    if (element) {
        $(element).html(text);
    } else {
        console.log(text);
    }
};


/*Rectangle.js*/

var Point = function(x, y) {
    this.x = x;
    this.y = y;
};

var Rectangle = function(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.left = x;
    this.right = x + width;
    this.top = y;
    this.bottom = y + height;
};

Rectangle.prototype.intersects = function(other) {
    return !(this.left > other.right || this.right < other.left || this.top > other.bottom || this.bottom < other.top);
};

/*OffsetBuffer.js*/

var OffsetBuffer = function(data) {
    this.offset = 0;
    this.ab = data;
};

// Read various datatypes from the ArrayBuffer, seeking the offset.
OffsetBuffer.prototype.readString = function(length) {
    var str = this.ab2str(this.ab.slice(this.offset, this.offset + length));
    this.offset += length;
    return str;
};

OffsetBuffer.prototype.readInt = function() {
    var num = this.ab2int(this.ab.slice(this.offset, this.offset + 4));
    this.offset += 4;
    return num;
};

OffsetBuffer.prototype.readUint = function() {
    var num = this.ab2uint(this.ab.slice(this.offset, this.offset + 4));
    this.offset += 4;
    return num;
};

OffsetBuffer.prototype.readShort = function() {
    var num = this.ab2short(this.ab.slice(this.offset, this.offset + 2));
    this.offset += 2;
    return num;
};

OffsetBuffer.prototype.readBytes = function(length) {
    var bytes = this.ab.slice(this.offset, this.offset + length);
    this.offset += length;
    return bytes;
};

// Length of the internal buffer
OffsetBuffer.prototype.getLength = function() {
    return this.ab.byteLength;
};

// Number of bytes remaining from the current offset
OffsetBuffer.prototype.bytesAvailable = function() {
    return this.getLength() - this.offset;
};

// ArrayBuffer -> JS type conversion methods
OffsetBuffer.prototype.ab2str = function(buf) {
    return String.fromCharCode.apply(null, new Uint8Array(buf));
};

// These create Javascript Numbers
OffsetBuffer.prototype.ab2int = function(buf) {
    return new Int32Array(buf)[0];
};

OffsetBuffer.prototype.ab2uint = function(buf) {
    return new Uint32Array(buf)[0];
};

OffsetBuffer.prototype.ab2short = function(buf) {
    return new Int16Array(buf)[0];
};

/*Color.js*/

Color = function() {};

Color.fromHSV = function(h, s, v) {
    var r, g, b;
    h = h % 360;
    if (h < 0) h += 360;
    s = Math.max(0, Math.min(s, 1));
    v = Math.max(0, Math.min(v, 1));

    var i = Math.floor(h / 60);
    var f = (h / 60) - i;
    var p = v * (1 - s);
    var q = v * (1 - s * f);
    var t = v * (1 - s * (1 - f));
    if (i == 0) { r = v; g = t; b = p; }
    else if (i == 1) { r = q; g = v; b = p; }
    else if (i == 2) { r = p; g = v; b = t; }
    else if (i == 3) { r = p; g = q; b = v; }
    else if (i == 4) { r = t; g = p; b = v; }
    else if (i == 5) { r = v; g = p; b = q; }
    r = Math.floor(r * 255);
    g = Math.floor(g * 255);
    b = Math.floor(b * 255);
    return (r << 16) | (g << 8) | b;
};

Color.rgb2hsv = function(rgb) {
    var h, s, v, x, f, i;
    var r = ((rgb >> 16) & 255) / 255;
    var g = ((rgb >> 8) & 255) / 255;
    var b = (rgb & 255) / 255;
    x = Math.min(Math.min(r, g), b);
    v = Math.max(Math.max(r, g), b);
    if (x == v) return [0, 0, v]; // gray; hue arbitrarily reported as zero
    f = r == x ? g - b : g == x ? b - r : r - g;
    i = r == x ? 3 : g == x ? 5 : 1;
    h = ((i - f / (v - x)) * 60) % 360;
    s = (v - x) / v;
    return [h, s, v];
};

Color.scaleBrightness = function(rgb, scale) {
    var hsv = Color.rgb2hsv(rgb);
    scale = Math.max(0, Math.min(scale, 1));
    return Color.fromHSV(hsv[0], hsv[1], scale * hsv[2]);
};

Color.mixRGB = function(rgb1, rgb2, fraction) {
    // Mix rgb1 with rgb2. 0 gives all rgb1, 1 gives rbg2, .5 mixes them 50/50.
    if (fraction <= 0) return rgb1;
    if (fraction >= 1) return rgb2;
    var r1 = (rgb1 >> 16) & 255;
    var g1 = (rgb1 >> 8) & 255;
    var b1 = rgb1 & 255
    var r2 = (rgb2 >> 16) & 255;
    var g2 = (rgb2 >> 8) & 255;
    var b2 = rgb2 & 255
    var r = ((fraction * r2) + ((1.0 - fraction) * r1)) & 255;
    var g = ((fraction * g2) + ((1.0 - fraction) * g1)) & 255;
    var b = ((fraction * b2) + ((1.0 - fraction) * b1)) & 255;
    return (r << 16) | (g << 8) | b;
};

Color.random = function() {
    // return a random color
    var h = 360 * Math.random();
    var s = 0.7 + (0.3 * Math.random());
    var v = 0.6 + (0.4 * Math.random());
    return Color.fromHSV(h, s, v);
};


/*Stage.js*/

'use strict';

var Stage = function(data) {
    // Place the background layer in the very back.
    // The pen layer is right above the stage background,
    // and all sprites are above that.
    this.z = -2;

    // Pen layer and canvas cache.
    this.penLayerLoaded = false;
    this.lineCanvas = document.createElement('canvas');
    this.lineCanvas.width = 480;
    this.lineCanvas.height = 360;
    this.lineCache = this.lineCanvas.getContext('2d');
    this.isStage = true;
    this.askAnswer = ""; //this is a private variable and should be blank

    Sprite.call(this, data);
};

Stage.prototype = Object.create(Sprite.prototype);
Stage.prototype.constructor = Stage;

Stage.prototype.attachPenLayer = function(scene) {
    if (this.penLayerLoaded) return;
    this.penLayerLoaded = true;
    $(this.lineCanvas).css('position', 'absolute');
    $(this.lineCanvas).css('z-index', '-1');
    scene.append(this.lineCanvas);
};

Stage.prototype.isLoaded = function() {
    return this.penLayerLoaded && this.costumesLoaded == this.costumes.length && this.soundsLoaded == Object.keys(this.sounds).length;
};

// Pen functions
Stage.prototype.clearPenStrokes = function() {
    this.lineCache.clearRect(0, 0, 480, 360);
};

Stage.prototype.stroke = function(from, to, width, color) {
    this.lineCache.lineWidth = width;
    this.lineCache.lineCap = 'round';
    this.lineCache.beginPath();
    // Use .5 offsets for canvas rigid pixel drawing
    this.lineCache.moveTo(from[0] + 240.5, 180.5 - from[1]);
    this.lineCache.lineTo(to[0] + 240.5, 180.5 - to[1]);
    this.lineCache.strokeStyle = 'rgb(' + (color >>> 16 & 255) + ',' + (color >>> 8 & 255) + ',' + (color >>> 0 & 255) + ')';
    this.lineCache.stroke();
};

/*Sprite.js*/
'use strict';

var Sprite = function(data) {
    if (!this.data) {
        this.data = data;
    }

    // Public variables used for Scratch-accessible data.
    this.visible = typeof(this.data.visible) == "undefined" ? true : data.visible;

    this.scratchX = data.scratchX || 0;
    this.scratchY = data.scratchY || 0;

    this.scale = data.scale || 1.0;

    this.direction = data.direction || 90;
    this.rotation = (data.direction - 90) || 0;
    this.rotationStyle = data.rotationStyle || 'normal';
    this.isFlipped = data.direction < 0 && data.rotationStyle == 'leftRight';
    this.costumes = data.costumes || [];
    this.currentCostumeIndex = Math.floor(data.currentCostumeIndex) || 0;
    this.previousCostumeIndex = -1;

    this.objName = data.objName || '';

    this.variables = {};
    if (data.variables) {
        for (var i = 0; i < data.variables.length; i++) {
            this.variables[data.variables[i]['name']] = data.variables[i]['value'];
        }
    }
    this.lists = {};
    if (data.lists) {
        for (var i = 0; i < data.lists.length; i++) {
            this.lists[data.lists[i]['listName']] = data.lists[i];
        }
    }

    // Used for the pen
    this.penIsDown = false;
    this.penWidth = 1;
    this.penHue = 120; // blue
    this.penShade = 50; // full brightness and saturation
    this.penColorCache = 0x0000FF;

    // Used for layering
    if (!this.z) this.z = io.getCount();

    // HTML element for the talk bubbles
    this.talkBubble = null;
    this.talkBubbleBox = null;
    this.talkBubbleStyler = null;
    this.talkBubbleOn = false;

    // HTML element for the ask bubbles
    this.askInput = null;
    this.askInputField = null;
    this.askInputButton = null;
    this.askInputOn = false;

    // Internal variables used for rendering meshes.
    this.textures = [];
    this.materials = [];
    this.geometries = [];
    this.mesh = null;

    // Sound buffers and data
    this.sounds = {};
    if (data.sounds) {
        for (var i = 0; i < data.sounds.length; i++) {
            this.sounds[data.sounds[i]['soundName']] = data.sounds[i];
        }
    }
    this.soundsLoaded = 0;
    this.instrument = 1;

    // Image effects
    this.filters = {
        color: 0,
        fisheye: 0,
        whirl: 0,
        pixelate: 0,
        mosaic: 0,
        brightness: 0,
        ghost: 0
    };

    // Incremented when images are loaded by the browser.
    this.costumesLoaded = 0;

    // Stacks to be pushed to the interpreter and run
    this.stacks = [];
};

// Attaches a Sprite (<img>) to a Scratch scene
Sprite.prototype.attach = function(scene) {
    // Create textures and materials for each of the costumes.
    for (var c in this.costumes) {
        this.textures[c] = document.createElement('img');
        $(this.textures[c])
        .load([this, c], function(evo) {
            var sprite = evo.handleObj.data[0];
            var c = evo.handleObj.data[1];

            sprite.costumesLoaded += 1;
            sprite.updateCostume();

            $(sprite.textures[c]).css('display', sprite.currentCostumeIndex == c ? 'inline' : 'none');
            $(sprite.textures[c]).css('position', 'absolute').css('left', '0px').css('top', '0px');
            $(sprite.textures[c]).bind('dragstart', function(evt) { evt.preventDefault(); })
                .bind('selectstart', function(evt) { evt.preventDefault(); })
                .bind('touchend', function(evt) { sprite.onClick(evt); $(this).addClass('touched'); })
                .click(function(evt) {
                    if (!$(this).hasClass('touched')) {
                        sprite.onClick(evt);
                    } else {
                        $(this).removeClass('touched');
                    }
                });
            scene.append($(sprite.textures[c]));
        })
        .attr({
            'crossOrigin': 'anonymous',
            'src': io.asset_base + this.costumes[c].baseLayerMD5 + io.asset_suffix
        });
    }

    this.mesh = this.textures[this.currentCostumeIndex];
    this.updateLayer();
    this.updateVisible();
    this.updateTransform();

    if (! this.isStage) {
        this.talkBubble = $('<div class="bubble-container"></div>');
        this.talkBubble.css('display', 'none');
        this.talkBubbleBox = $('<div class="bubble"></div>');
        this.talkBubbleStyler = $('<div class="bubble-say"></div>');
        this.talkBubble.append(this.talkBubbleBox);
        this.talkBubble.append(this.talkBubbleStyler);
    }

    this.askInput = $('<div class="ask-container"></div>');
    this.askInput.css('display', 'none');
    this.askInputField = $('<div class="ask-field"></div>');
    this.askInputTextField = $('<input type="text" class="ask-text-field"></input>');
    this.askInputField.append(this.askInputTextField);
    this.askInputButton = $('<div class="ask-button"></div>');
    this.bindDoAskButton();
    this.askInput.append(this.askInputField);
    this.askInput.append(this.askInputButton);

    runtime.scene.append(this.talkBubble);
    runtime.scene.append(this.askInput);
};

// Load sounds from the server and buffer them
Sprite.prototype.loadSounds = function() {
    var self = this;
    $.each(this.sounds, function(index, sound) {
        io.soundRequest(sound, self);
    });
};

// True when all the costumes have been loaded
Sprite.prototype.isLoaded = function() {
    return this.costumesLoaded == this.costumes.length && this.soundsLoaded == Object.keys(this.sounds).length;
};

// Step methods
Sprite.prototype.showCostume = function(costume) {
    if (costume < 0) {
        costume += this.costumes.length;
    }
    if (!this.textures[costume]) {
        this.currentCostumeIndex = 0;
    }
    else {
        this.currentCostumeIndex = costume;
    }
    this.updateCostume();
};

Sprite.prototype.indexOfCostumeNamed = function(name) {
    for (var i in this.costumes) {
        var c = this.costumes[i];
        if (c['costumeName'] == name) {
            return i;
        }
    }
    return null;
};

Sprite.prototype.showCostumeNamed = function(name) {
    var index = this.indexOfCostumeNamed(name);
    if (!index) return;
    this.showCostume(index);
};

Sprite.prototype.updateCostume = function() {
    if (!this.textures[this.currentCostumeIndex]) {
        this.currentCostumeIndex = 0;
    }
    $(this.mesh).css('display', 'none');
    this.mesh = this.textures[this.currentCostumeIndex];
    this.updateVisible();
    this.updateTransform();
};

Sprite.prototype.onClick = function(evt) {
    // TODO - needs work!!

    // We don't need boxOffset anymore.
    var mouseX = runtime.mousePos[0] + 240;
    var mouseY = 180 - runtime.mousePos[1];

    var canv = document.createElement('canvas');
    canv.width = 480;
    canv.height = 360;
    var ctx = canv.getContext('2d');
    var drawWidth = this.textures[this.currentCostumeIndex].width;
    var drawHeight = this.textures[this.currentCostumeIndex].height;
    var scale = this.scale / (this.costumes[this.currentCostumeIndex].bitmapResolution || 1);
    var rotationCenterX = this.costumes[this.currentCostumeIndex].rotationCenterX;
    var rotationCenterY = this.costumes[this.currentCostumeIndex].rotationCenterY;
    ctx.translate(240 + this.scratchX, 180 - this.scratchY);
    ctx.rotate(this.rotation * Math.PI / 180.0);
    ctx.scale(scale, scale);
    ctx.translate(-rotationCenterX, -rotationCenterY);
    ctx.drawImage(this.mesh, 0, 0);

    var alpha;
    try {
        var idata = ctx.getImageData(mouseX, mouseY, 1, 1).data;
        alpha = idata[3];
    } catch (e) {
        // as of 2014-09-06, WebKit/Safari still throws a security exception trying to read
        // image data from a canvas after any svg has been draw to it. Version 7.0.6 (9537.78.2)
        // WebKit-nightly (SVN-r173347) does not have this issue.
        alpha = 1;
    }

    if (alpha > 0) {
        // Start clicked hats if the pixel is non-transparent
        runtime.startClickedHats(this);
    } else {
        // Otherwise, move back a layer and trigger the click event
        $(this.mesh).hide();
        var bb = $('#container')[0].getBoundingClientRect();
        var underElement = document.elementFromPoint(bb.left + mouseX, bb.top + mouseY);
        $(underElement).click();
        $(this.mesh).show();
    }
};

Sprite.prototype.setVisible = function(v) {
    this.visible = v;
    this.updateVisible();
};

Sprite.prototype.updateLayer = function() {
    $(this.mesh).css('z-index', this.z);
    if (this.talkBubble) this.talkBubble.css('z-index', this.z);
    if (this.askInput) this.askInput.css('z-index', this.z);
};

Sprite.prototype.updateVisible = function() {
    $(this.mesh).css('display', this.visible ? 'inline' : 'none');
    if (this.talkBubbleOn) this.talkBubble.css('display', this.visible ? 'inline-block' : 'none');
    if (this.askInputOn) this.askInput.css('display', this.visible ? 'inline-block' : 'none');
};

Sprite.prototype.updateTransform = function() {
    var texture = this.textures[this.currentCostumeIndex];
    var resolution = this.costumes[this.currentCostumeIndex].bitmapResolution || 1;

    var drawWidth = texture.width * this.scale / resolution;
    var drawHeight = texture.height * this.scale / resolution;

    var rotationCenterX = this.costumes[this.currentCostumeIndex].rotationCenterX;
    var rotationCenterY = this.costumes[this.currentCostumeIndex].rotationCenterY;

    var drawX = this.scratchX + (480 / 2) - rotationCenterX;
    var drawY = -this.scratchY + (360 / 2) - rotationCenterY;

    var scaleXprepend = '';
    if (this.isFlipped) {
        scaleXprepend = '-'; // For a leftRight flip, we add a minus
        // sign to the X scale.
    }

    $(this.mesh).css(
        'transform',
        'translatex(' + drawX + 'px) ' +
        'translatey(' + drawY + 'px) ' +
        'rotate(' + this.rotation + 'deg) ' +
        'scaleX(' + scaleXprepend + (this.scale / resolution) + ') scaleY(' +  (this.scale / resolution) + ')'
    );
    $(this.mesh).css(
        '-moz-transform',
        'translatex(' + drawX + 'px) ' +
        'translatey(' + drawY + 'px) ' +
        'rotate(' + this.rotation + 'deg) ' +
        'scaleX(' + scaleXprepend + this.scale + ') scaleY(' +  this.scale / resolution + ')'
    );
    $(this.mesh).css(
        '-webkit-transform',
        'translatex(' + drawX + 'px) ' +
        'translatey(' + drawY + 'px) ' +
        'rotate(' + this.rotation + 'deg) ' +
        'scaleX(' + scaleXprepend + (this.scale / resolution) + ') scaleY(' +  (this.scale / resolution) + ')'
    );

    $(this.mesh).css('-webkit-transform-origin', rotationCenterX + 'px ' + rotationCenterY + 'px');
    $(this.mesh).css('-moz-transform-origin', rotationCenterX + 'px ' + rotationCenterY + 'px');
    $(this.mesh).css('-ms-transform-origin', rotationCenterX + 'px ' + rotationCenterY + 'px');
    $(this.mesh).css('-o-transform-origin', rotationCenterX + 'px ' + rotationCenterY + 'px');
    $(this.mesh).css('transform-origin', rotationCenterX + 'px ' + rotationCenterY + 'px');

    // Don't forget to update the talk bubble.
    if (this.talkBubble) {
        var xy = this.getTalkBubbleXY();
        this.talkBubble.css('left', xy[0] + 'px');
        this.talkBubble.css('top', xy[1] + 'px');
    }

    this.updateLayer();
};

Sprite.prototype.updateFilters = function() {
    $(this.mesh).css('opacity', 1 - this.filters.ghost / 100);
    $(this.mesh).css(
        '-webkit-filter',
        'hue-rotate(' + (this.filters.color * 1.8) + 'deg) ' +
        'brightness(' + (this.filters.brightness < 0 ? this.filters.brightness / 100 + 1 : Math.min(2.5, this.filters.brightness * .015 + 1)) + ')'
    );
};

Sprite.prototype.getTalkBubbleXY = function() {
    var texture = this.textures[this.currentCostumeIndex];
    var drawWidth = texture.width * this.scale;
    var drawHeight = texture.height * this.scale;
    var rotationCenterX = this.costumes[this.currentCostumeIndex].rotationCenterX;
    var rotationCenterY = this.costumes[this.currentCostumeIndex].rotationCenterY;
    var drawX = this.scratchX + (480 / 2) - rotationCenterX;
    var drawY = -this.scratchY + (360 / 2) - rotationCenterY;
    return [drawX + drawWidth, drawY - drawHeight / 2];
};

Sprite.prototype.showBubble = function(text, type) {
    var xy = this.getTalkBubbleXY();

    this.talkBubbleOn = true;
    this.talkBubble.css('z-index', this.z);
    this.talkBubble.css('left', xy[0] + 'px');
    this.talkBubble.css('top', xy[1] + 'px');

    this.talkBubbleBox.removeClass('say-think-border');
    this.talkBubbleBox.removeClass('ask-border');

    this.talkBubbleStyler.removeClass('bubble-say');
    this.talkBubbleStyler.removeClass('bubble-think');
    this.talkBubbleStyler.removeClass('bubble-ask');
    if (type == 'say') {
        this.talkBubbleBox.addClass('say-think-border');
        this.talkBubbleStyler.addClass('bubble-say');
    } else if (type == 'think') {
        this.talkBubbleBox.addClass('say-think-border');
        this.talkBubbleStyler.addClass('bubble-think');
    } else if (type == 'doAsk') {
        this.talkBubbleBox.addClass('ask-border');
        this.talkBubbleStyler.addClass('bubble-ask');
    }

    if (this.visible) {
        this.talkBubble.css('display', 'inline-block');
    }
    this.talkBubbleBox.html(text);
};

Sprite.prototype.hideBubble = function() {
    this.talkBubbleOn = false;
    this.talkBubble.css('display', 'none');
};

Sprite.prototype.showAsk = function() {
    this.askInputOn = true;
    this.askInput.css('z-index', this.z);
    this.askInput.css('left', '15px');
    this.askInput.css('right', '15px');
    this.askInput.css('bottom', '7px');
    this.askInput.css('height', '25px');

    if (this.visible) {
        this.askInput.css('display', 'inline-block');
        this.askInputTextField.focus();
    }
};

Sprite.prototype.hideAsk = function() {
    this.askInputOn = false;
    this.askInputTextField.val('');
    this.askInput.css('display', 'none');
};

Sprite.prototype.bindDoAskButton = function() {
    var self = this;
    this.askInputButton.on("keypress click", function(e) {
        var eType = e.type;
        if (eType === 'click' || (eType === 'keypress' && e.which === 13)) {
            var stage = interp.targetStage();
            stage.askAnswer = $(self.askInputTextField).val();
            self.hideBubble();
            self.hideAsk();
            interp.activeThread.paused = false;
        }
    });
};

Sprite.prototype.setXY = function(x, y) {
    this.scratchX = x;
    this.scratchY = y;
    this.updateTransform();
};

Sprite.prototype.setDirection = function(d) {
    var rotation;
    d = d % 360
    if (d < 0) d += 360;
    this.direction = d > 180 ? d - 360 : d;
    if (this.rotationStyle == 'normal') {
        rotation = (this.direction - 90) % 360;
    } else if (this.rotationStyle == 'leftRight') {
        if (((this.direction - 90) % 360) >= 0) {
            this.isFlipped = false;
        } else {
            this.isFlipped = true;
        }
        rotation = 0;
    } else {
        rotation = 0;
    }
    this.rotation = rotation;
    this.updateTransform();
};

Sprite.prototype.setRotationStyle = function(r) {
    this.rotationStyle = r;
};

Sprite.prototype.getSize = function() {
    return this.scale * 100;
};

Sprite.prototype.setSize = function(percent) {
    var newScale = percent / 100.0;
    newScale = Math.max(0.05, Math.min(newScale, 100));
    this.scale = newScale;
    this.updateTransform();
};

// Move functions
Sprite.prototype.keepOnStage = function() {
    var x = this.scratchX + 240;
    var y = 180 - this.scratchY;
    var myBox = this.getRect();
    var inset = -Math.min(18, Math.min(myBox.width, myBox.height) / 2);
    var edgeBox = new Rectangle(inset, inset, 480 - (2 * inset), 360 - (2 * inset));
    if (myBox.intersects(edgeBox)) return; // sprite is sufficiently on stage
    if (myBox.right < edgeBox.left) x += edgeBox.left - myBox.right;
    if (myBox.left > edgeBox.right) x -= myBox.left - edgeBox.right;
    if (myBox.bottom < edgeBox.top) y += edgeBox.top - myBox.bottom;
    if (myBox.top > edgeBox.bottom) y -= myBox.top - edgeBox.bottom;
    this.scratchX = x - 240;
    this.scratchY = 180 - y;
};

Sprite.prototype.getRect = function() {
    var cImg = this.textures[this.currentCostumeIndex];
    var x = this.scratchX + 240 - (cImg.width/2.0);
    var y = 180 - this.scratchY - (cImg.height/2.0);
    var myBox = new Rectangle(x, y, cImg.width, cImg.height);
    return myBox;
};

// Pen functions
Sprite.prototype.setPenColor = function(c) {
    var hsv = Color.rgb2hsv(c);
    this.penHue = (200 * hsv[0]) / 360 ;
    this.penShade = 50 * hsv[2];  // not quite right; doesn't account for saturation
    this.penColorCache = c;
};

Sprite.prototype.setPenHue = function(n) {
    this.penHue = n % 200;
    if (this.penHue < 0) this.penHue += 200;
    this.updateCachedPenColor();
};

Sprite.prototype.setPenShade = function(n) {
    this.penShade = n % 200;
    if (this.penShade < 0) this.penShade += 200;
    this.updateCachedPenColor();
};

Sprite.prototype.updateCachedPenColor = function() {
    var c = Color.fromHSV((this.penHue * 180.0) / 100.0, 1, 1);
    var shade = this.penShade > 100 ? 200 - this.penShade : this.penShade; // range 0..100
    if (shade < 50) {
        this.penColorCache = Color.mixRGB(0, c, (10 + shade) / 60.0);
    } else {
        this.penColorCache = Color.mixRGB(c, 0xFFFFFF, (shade - 50) / 60);
    }
};

Sprite.prototype.stamp = function(canvas, opacity) {
    var resolution = this.costumes[this.currentCostumeIndex].bitmapResolution || 1;
    var drawWidth = this.textures[this.currentCostumeIndex].width;
    var drawHeight = this.textures[this.currentCostumeIndex].height;
    var drawX = this.scratchX + (480 / 2);
    var drawY = -this.scratchY + (360 / 2);
    var rotationCenterX = this.costumes[this.currentCostumeIndex].rotationCenterX;
    var rotationCenterY = this.costumes[this.currentCostumeIndex].rotationCenterY;
    canvas.globalAlpha = opacity / 100.0;
    canvas.save();
    canvas.translate(drawX, drawY);
    canvas.scale(this.scale / resolution, this.scale / resolution);
    canvas.rotate(this.rotation * Math.PI / 180.0);
    canvas.drawImage(this.mesh, -rotationCenterX, -rotationCenterY, drawWidth, drawHeight);
    canvas.restore();
    canvas.globalAlpha = 1;
};

Sprite.prototype.soundNamed = function(name) {
    if (name in this.sounds && this.sounds[name].buffer) {
        return this.sounds[name];
    } else if (name in runtime.stage.sounds && runtime.stage.sounds[name].buffer) {
        return runtime.stage.sounds[name];
    }
    return null;
};

Sprite.prototype.resetFilters = function() {
    this.filters = {
        color: 0,
        fisheye: 0,
        whirl: 0,
        pixelate: 0,
        mosaic: 0,
        brightness: 0,
        ghost: 0
    };
    this.updateFilters();
};

/*Scratch.js*/

'use strict';

var runtime, interp, io, iosAudioActive = false;
function Scratch(project_id) {
    runtime = new Runtime();
    runtime.init();

    $(window).keydown(function(e) {
        runtime.keysDown[e.which] = true;
        runtime.startKeyHats(e.which);
    });

    $(window).keyup(function(e) {
        delete runtime.keysDown[e.which];
    });

    var address = $('#address-hint');
    var project = $('#project-id');

    // Update the project ID field
    project.val(project_id);

    // Validate project ID field
    project.keyup(function() {
        var n = this.value;

        // Allow URL pasting
        var e = /projects\/(\d+)/.exec(n);
        if (e) {
            n = this.value = e[1];
        }

        // Eventually, this will xhr to /projects/{{this.value}}/ and
        // change color based on whether the response is 404 or 200.
        $('#project-id, #address-hint').toggleClass('error', isNaN(n));
    });

    // Focus the actual input when the user clicks on the URL hint
    address.click(function() {
        project.select();
    });

    var width = address.outerWidth();
    project.css({
        paddingLeft: width,
        marginLeft: -width
    });

    // Go project button behavior
    $('#go-project').click(function() {
        window.location = '#' + parseInt($('#project-id').val());
        window.location.reload(true);
    });

    // Green flag behavior
    $('#trigger-green-flag, #overlay').click(function() {
        if (!runtime.projectLoaded) return;
        $('#overlay').css('display', 'none');
        runtime.greenFlag()
    });

    // Stop button behavior
    $('#trigger-stop').click(function() {
        runtime.stopAll();
    });

    // Canvas container mouse events
    $('#container').mousedown(function(e) {
        runtime.mouseDown = true;
        //e.preventDefault();
    });

    $('#container').mouseup(function(e) {
        runtime.mouseDown = false;
        //e.preventDefault();
    });

    $('#container').mousemove(function(e) {
        var bb = this.getBoundingClientRect();
        var absX = e.clientX - bb.left;
        var absY = e.clientY - bb.top;
        runtime.mousePos = [absX-240, -absY+180];
    });

    // Touch events - EXPERIMENTAL
    $(window).bind('touchstart', function(e) {
        // On iOS, we need to activate the Web Audio API
        // with an empty sound play on the first touch event.
        if (!iosAudioActive) {
            var ibuffer = runtime.audioContext.createBuffer(1, 1, 22050);
            var isource = runtime.audioContext.createBufferSource();
            isource.buffer = ibuffer;
            isource.connect(runtime.audioContext.destination);
            isource.start();
            iosAudioActive = true;
        }
    });

    $('#container').bind('touchstart', function(e) {
        runtime.mouseDown = true;
    });

    $('#container').bind('touchend', function(e) {
        runtime.mouseDown = true;
    });

    $('#container').bind('touchmove', function(e) {
        var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
        var bb = this.getBoundingClientRect();
        var absX = touch.clientX - bb.left;
        var absY = touch.clientY - bb.top;
        runtime.mousePos = [absX-240, -absY+180];
    });

    // Border touch events - EXPERIMENTAL
    $('#left').bind('touchstart touchmove', function(e) { runtime.keysDown[37] = true; runtime.startKeyHats(37); });
    $('#left').bind('touchend', function(e) { delete runtime.keysDown[37]; });
    $('#up').bind('touchstart touchmove', function(e) { runtime.keysDown[38] = true; runtime.startKeyHats(38); });
    $('#up').bind('touchend', function(e) { delete runtime.keysDown[38]; });
    $('#right').bind('touchstart touchmove', function(e) { runtime.keysDown[39] = true; runtime.startKeyHats(39); });
    $('#right').bind('touchend', function(e) { delete runtime.keysDown[39]; });
    $('#down').bind('touchstart touchmove', function(e) { runtime.keysDown[40] = true; runtime.startKeyHats(40); });
    $('#down').bind('touchend', function(e) { delete runtime.keysDown[40]; });

    // Load the interpreter and primitives
    interp = new Interpreter();
    interp.initPrims();

    // Load the requested project and go!
    io = new IO();
    io.loadProject(project_id);
};

/*Runtime.js*/

'use strict';

var t = new Timer();

var Runtime = function() {
    this.scene = null;
    this.sprites = [];
    this.reporters = [];
    this.keysDown = {};
    this.mouseDown = false;
    this.mousePos = [0, 0];
    this.audioContext = null;
    this.audioGain = null;
    this.audioPlaying = [];
    this.notesPlaying = [];
    this.projectLoaded = false;
};

// Initializer for the drawing and audio contexts.
Runtime.prototype.init = function() {
    this.scene = $('#container');
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    this.audioContext = new AudioContext();
    try {
        this.audioGain = this.audioContext.createGain();
    } catch(err) {
        this.audioGain = this.audioContext.createGainNode();
    }
    this.audioGain.connect(runtime.audioContext.destination);
};

// Load start waits for the stage and the sprites to be loaded, without
// hanging the browser.  When the loading is finished, we begin the step
// and animate methods.
Runtime.prototype.loadStart = function() {
    if (!runtime.stage.isLoaded()) {
        setTimeout(function(runtime) { runtime.loadStart(); }, 50, this);
        return;
    }
    for (var obj = 0; obj < runtime.sprites.length; obj++) {
        if (typeof(runtime.sprites[obj]) == 'object' && runtime.sprites[obj].constructor == Sprite) {
            if (!runtime.sprites[obj].isLoaded()) {
                setTimeout(function(runtime) { runtime.loadStart(); }, 50, this);
                return;
            }
        }
    }
    if (Instr.wavsLoaded != Instr.wavCount) {
        setTimeout(function(runtime) { runtime.loadStart(); }, 50, this);
        return;
    }
    $('#preloader').css('display', 'none');
    setInterval(this.step, 33);
    this.projectLoaded = true;
};

Runtime.prototype.greenFlag = function() {
    if (this.projectLoaded) {
        interp.activeThread = new Thread(null);
        interp.threads = [];
        interp.primitiveTable.timerReset();
        this.startGreenFlags();
    }
};

Runtime.prototype.stopAll = function() {
    interp.activeThread = new Thread(null);
    interp.threads = [];
    stopAllSounds();
    // Hide sprite bubbles, resetFilters and doAsk prompts
    for (var s = 0; s < runtime.sprites.length; s++) {
        if (runtime.sprites[s].hideBubble) runtime.sprites[s].hideBubble();
        if (runtime.sprites[s].resetFilters) runtime.sprites[s].resetFilters();
        if (runtime.sprites[s].hideAsk) runtime.sprites[s].hideAsk();
    }
    // Reset graphic effects
    runtime.stage.resetFilters();
};

// Step method for execution - called every 33 milliseconds
Runtime.prototype.step = function() {
    interp.stepThreads();
    for (var r = 0; r < runtime.reporters.length; r++) {
        runtime.reporters[r].update();
    }
};

// Stack functions -- push and remove stacks
// to be run by the interpreter as threads.
Runtime.prototype.allStacksDo = function(f) {
    var stage = runtime.stage;
    var stack;
    for (var i = runtime.sprites.length-1; i >= 0; i--) {
        var o = runtime.sprites[i];
        if (typeof(o) == 'object' && o.constructor == Sprite) {
            $.each(o.stacks, function(index, stack) {
                f(stack, o);
            });
        }
    }
    $.each(stage.stacks, function(index, stack) {
        f(stack, stage);
    });
};

// Hat triggers
Runtime.prototype.startGreenFlags = function() {
    function startIfGreenFlag(stack, target) {
        if (stack.op == 'whenGreenFlag') interp.toggleThread(stack, target);
    }
    this.allStacksDo(startIfGreenFlag);
};

Runtime.prototype.startKeyHats = function(ch) {
    var keyName = null;
    if (('A'.charCodeAt(0) <= ch) && (ch <= 'Z'.charCodeAt(0)) ||
        ('a'.charCodeAt(0) <= ch) && (ch <= 'z'.charCodeAt(0)))
        keyName = String.fromCharCode(ch).toLowerCase();
    if (('0'.charCodeAt(0) <= ch) && (ch <= '9'.charCodeAt(0)))
        keyName = String.fromCharCode(ch);

    if (ch == 37) keyName = "left arrow";
    if (ch == 39) keyName = "right arrow";
    if (ch == 38) keyName = "up arrow";
    if (ch == 40) keyName = "down arrow";
    if (ch == 32) keyName = "space";

    if (keyName == null) return;
    var startMatchingKeyHats = function(stack, target) {
        if ((stack.op == "whenKeyPressed") && (stack.args[0] == keyName)) {
            // Only start the stack if it is not already running
            if (!interp.isRunning(stack)) {
                interp.toggleThread(stack, target);
            }
        }
    }
    runtime.allStacksDo(startMatchingKeyHats);
};

Runtime.prototype.startClickedHats = function(sprite) {
    function startIfClicked(stack, target) {
        if (target == sprite && stack.op == "whenClicked" && !interp.isRunning(stack)) {
            interp.toggleThread(stack, target);
        }
    }
    runtime.allStacksDo(startIfClicked);
};

// Returns true if a key is pressed.
Runtime.prototype.keyIsDown = function(ch) {
    return this.keysDown[ch] || false;
};

// Sprite named -- returns one of the sprites on the stage.
Runtime.prototype.spriteNamed = function(n) {
    if (n == 'Stage') return this.stage;
    var selected_sprite = null;
    $.each(this.sprites, function(index, s) {
        if (s.objName == n) {
            selected_sprite = s;
            return false;
        }
    });
    return selected_sprite;
};

Runtime.prototype.getTimeString = function(which) {
    // Return local time properties.
    var now = new Date();
    switch (which) {
        case 'hour': return now.getHours();
        case 'minute': return now.getMinutes();
        case 'second': return now.getSeconds();
        case 'year': return now.getFullYear(); // four digit year (e.g. 2012)
        case 'month': return now.getMonth() + 1; // 1-12
        case 'date': return now.getDate(); // 1-31
        case 'day of week': return now.getDay() + 1; // 1-7, where 1 is Sunday
    }
    return ''; // shouldn't happen
};

// Reassigns z-indices for layer functions
Runtime.prototype.reassignZ = function(target, move) {
    var sprites = this.sprites;
    var oldIndex = -1;
    $.each(this.sprites, function(index, sprite) {
        if (sprite == target) {
            // Splice out the sprite from its old position
            oldIndex = index;
            sprites.splice(index, 1);
        }
    });

    if (move == null) {
        // Move to the front
        this.sprites.splice(this.sprites.length, 0, target);
    } else if (oldIndex - move >= 0 && oldIndex - move < this.sprites.length + 1) {
        // Move to the new position
        this.sprites.splice(oldIndex - move, 0, target);
    } else {
        // No change is required
        this.sprites.splice(oldIndex, 0, target);
    }

    // Renumber the z-indices
    var newZ = 1;
    $.each(this.sprites, function(index, sprite) {
        sprite.z = newZ;
        sprite.updateLayer();
        newZ++;
    });
};

/*Reporter.js*/

'use strict';

var Reporter = function(data) {
    this.cmd = data.cmd;
    this.color = data.color;
    this.isDiscrete = data.isDiscrete;
    this.mode = data.mode;
    this.param = data.param;
    this.sliderMin = data.sliderMin;
    this.sliderMax = data.sliderMax;
    this.target = data.target;
    this.visible = data.visible;
    this.x = data.x;
    this.y = data.y;
    this.z = io.getCount();

    //Set the label after hydrating the cmd and param variables
    this.label = this.determineReporterLabel();

    this.el = null; // jQuery Element for the outer box
    this.valueEl = null; // jQ element containing the reporter value
    this.slider = null; // slider jQ element
};

Reporter.prototype.determineReporterLabel = function() {
    if (this.target === 'Stage' && this.cmd === "getVar:") return this.param;
    if (this.target === 'Stage' && this.param === null) return this.cmd;
    return this.target + ': ' + this.param;
}

Reporter.prototype.attach = function(scene) {
    switch (this.mode) {
        case 1: // Normal
        case 3: // Slider
            this.el = $('<div class="reporter-normal">' + this.label + '</div>');
            this.valueEl = $('<div class="reporter-inset">null</div>');
            this.el.append(this.valueEl);
            if (this.mode == 3) {
                // Slider-specific
                // Temporarily, set the value to sliderMin until an update
                this.slider = $('<input type="range" min="' + this.sliderMin +
                                '" max="' + this.sliderMax + '" step="1" value="' +
                                this.sliderMin + '" data-target="' + this.target +
                                '" data-var="' + this.param + '">');
                this.slider.change(this.changeSlider);
                this.el.append('<br>');
                this.el.append(this.slider);
            }
            break;
        case 2: // Large
            this.el = $('<div class="reporter-large">null</div>');
            this.valueEl = this.el;
            break;
    }
    this.el.css('left', this.x);
    this.el.css('top', this.y);
    this.el.css('z-index', this.z);
    var cR = (this.color >> 16);
    var cG = (this.color >> 8 & 255);
    var cB = (this.color & 255);
    this.valueEl.css('background-color', 'rgb(' + cR + ',' + cG + ',' + cB + ')');
    this.el.css('display', this.visible ? 'inline-block' : 'none');
    scene.append(this.el);
};

Reporter.prototype.update = function() {
    this.el.css('display', this.visible ? 'inline-block' : 'none');
    if (!this.visible) return;

    var newValue = '';
    var target = runtime.spriteNamed(this.target);
    switch (this.cmd) {
        case 'answer':
            newValue = target.askAnswer;
            break;
        case 'getVar:':
            newValue = target.variables[this.param];
            break;
        case 'xpos':
            newValue = target.scratchX;
            break;
        case 'ypos':
            newValue = target.scratchY;
            break;
        case 'heading':
            newValue = target.direction;
            break;
        case 'scale':
            newValue = target.getSize();
            break;
        case 'sceneName':
            newValue = runtime.stage.costumes[runtime.stage.currentCostumeIndex].costumeName;
            break;
        case 'costumeIndex':
            newValue = target.currentCostumeIndex + 1;
            break;
        case 'timer':
            newValue = '' + Math.round(interp.primitiveTable.timer() * 10) / 10;
            break;
    }
    if (typeof newValue === 'number' && Math.abs(newValue) > 0.001) {
        newValue = Math.round(newValue * 1000) / 1000;
    }
    newValue = '' + newValue;
    this.valueEl.html(newValue);
    if (this.mode == 3) {
        this.slider.val(Number(newValue));
    }
};

Reporter.prototype.updateLayer = function() {
    this.el.css('z-index', this.z);
};

Reporter.prototype.changeSlider = function() {
    var newValue = Number($(this).val());
    var target = runtime.spriteNamed($(this).attr('data-target'));
    var variable = $(this).attr('data-var');
    target.variables[variable] = newValue;
};

var List = function(data, sprite) {
    this.contents = data.contents;
    this.listName = data.listName;

    this.height = data.height;
    this.width = data.width;
    this.x = data.x;
    this.y = data.y;
    this.z = io.getCount();
    this.visible = data.visible;

    this.target = sprite;

//    this.isPersistent = data.isPersistent;

    this.el = null; // jQuery element for list
    this.containerEl = null;
    this.scrollbar = null;
};

List.prototype.attach = function(scene) {
    this.el = $('<div class="list">');
    this.el.append('<div class="list-title">'+(this.target==='Stage'?'':this.target+' ')+this.listName);
    var c = this.containerEl = $('<div style="overflow:hidden;float:left;position:relative">').appendTo(this.el).width(this.width-13).height(this.height-34);
    var s = this.scrollbar = $('<div class="list-scrollbar-container"><div class="list-scrollbar">').appendTo(this.el);
    var sb = s.children('.list-scrollbar');
    sb.mousedown(function(e) {
        if (e.which===1) $(this).data({scrolling:true,startY:e.pageY}); // left button
    });
    $('body').mousemove(function(e) {
        if (sb.data('scrolling')) {
            var offset = parseInt(sb.css('top'))+e.pageY-sb.data('startY');
            if (offset < 0) {
                offset = 0;
            }
            if (offset > c.height()-sb.height()) {
                offset = c.height()-sb.height();
            }
            sb.css('top',offset);
            c.scrollTop(c.height()/sb.height()*offset);
        }
    }).mouseup(function() {
        if ($.hasData(sb[0],'scrolling')) sb.removeData(['scrolling','startY']);
    });
//    this.el.append('<div class="list-add">+'); // disabled because it doesn't do anything even in the original
    this.el.append('<div class="list-length">length: '+this.contents.length);
    scene.append(this.el);
    this.update();
    this.el.css('left', this.x);
    this.el.css('top', this.y);
    this.el.width(this.width);
    this.el.height(this.height);
    this.el.css('z-index', this.z);
    this.el.css('display', this.visible ? 'inline-block' : 'none');
};

List.prototype.update = function() {
    this.contents = findList(runtime.spriteNamed(this.target),this.listName);

    this.el.css('display', this.visible ? 'inline-block' : 'none');
    if (!this.visible) return;

    var c = this.containerEl.html(''); // so that it can be used inside the forEach
    this.contents.forEach(function(val,i) {
        $('<div style="clear:both">').appendTo(c).append('<div class="list-index">'+(i+1),'<div class="list-item">'+val);
    });
    c.find('.list-index').width(c.find('.list-index').last().width());
    c.find('.list-item').width(c.width()-c.find('.list-index').width()-15);
    var s = this.scrollbar.height(c.height());
    s.children('.list-scrollbar').height(s.height()/c[0].scrollHeight*s.height()).css('display', s.children('.list-scrollbar').height()===c.height() ? 'none' : 'inline-block');
    this.el.find('.list-length').text('length: '+this.contents.length);
};

List.prototype.updateLayer = function() {
    this.el.css('z-index', this.z);
};


/*IO.js*/

'use strict';

var IO = function() {
    this.data = null;
    this.project_base = 'http://cdn.projects.scratch.mit.edu/internalapi/project/';
    this.project_suffix = '/get/';
    this.asset_base = 'http://cdn.assets.scratch.mit.edu/internalapi/asset/';
    this.asset_suffix = '/get/';
    this.soundbank_base = 'soundbank/';
    this.spriteLayerCount = 0;
};

IO.prototype.loadProject = function(project_id) {
    var self = this;
    $.getJSON(this.project_base + project_id + this.project_suffix, function(data) {
        self.data = data;
        self.makeObjects();
        self.loadThreads();
        self.loadNotesDrums();
        runtime.loadStart(); // Try to run the project.
    });
};

IO.prototype.soundRequest = function(sound, sprite) {
    var request = new XMLHttpRequest();
    request.open('GET', this.asset_base + sound['md5'] + this.asset_suffix, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
        var waveData = request.response;
        // Decode the waveData and populate a buffer channel with the samples
        var snd = new SoundDecoder(waveData);
        var samples = snd.getAllSamples();
        sound.buffer = runtime.audioContext.createBuffer(1, samples.length, runtime.audioContext.sampleRate);
        var data = sound.buffer.getChannelData(0);
        for (var i = 0; i < data.length; i++) {
            data[i] = samples[i];
        }
        sprite.soundsLoaded++;
    };
    request.send();
};

IO.prototype.loadNotesDrums = function() {
    var self = this;
    $.each(Instr.wavs, function(name, file) {
        var request = new XMLHttpRequest();
        request.open('GET', self.soundbank_base + escape(file), true);
        request.responseType = 'arraybuffer';
        request.onload = function() {
            var waveData = new OffsetBuffer(request.response);
            // Decode the waveData and populate a buffer channel with the samples
            var info = WAVFile.decode(request.response);
            waveData.offset = info.sampleDataStart;
            var soundBuffer = waveData.readBytes(2 * info.sampleCount);
            Instr.samples[name] = soundBuffer;
            Instr.wavsLoaded++;
        };
        request.send();
    });
};

IO.prototype.makeObjects = function() {
    // Create the stage
    runtime.stage = new Stage(this.data);
    runtime.stage.attach(runtime.scene);
    runtime.stage.attachPenLayer(runtime.scene);
    runtime.stage.loadSounds();
    // Create the sprites and watchers
    function createObj(obj, sprite) {
        var newSprite;
        function createSprite(obj) {
            var newSprite = new Sprite(obj);
            newSprite.loadSounds();
            return newSprite;
        }
        function createReporter(obj, sprite) {
            var newSprite;
            if (obj.listName) { // list
                if (!(sprite===runtime.stage && !runtime.stage.lists[obj.listName])) { // for local lists, only if in sprite
                    newSprite = new List(obj, sprite.objName);
                    runtime.reporters.push(newSprite);
                }
            } else {
                newSprite = new Reporter(obj);
                runtime.reporters.push(newSprite);
            }
            return newSprite;
        }
        if (typeof(obj.objName) === "string") { // sprite
            newSprite = createSprite(obj);
            sprite = newSprite;
        } else {
            newSprite = createReporter(obj, sprite);
        }
        if (newSprite) {
            runtime.sprites.push(newSprite);
            newSprite.attach(runtime.scene);
        }
    }
    $.each(this.data.children, function(index, obj) {
        createObj(obj, runtime.stage); // create children of stage - sprites, watchers, and stage's lists
    });
    $.each(runtime.sprites.filter(function(sprite) {return sprite instanceof Sprite}), function(index, sprite) { // list of sprites
        $.each(sprite.lists, function(index, list) {
            createObj(list, sprite); // create local lists
        });
    });
};

IO.prototype.loadThreads = function() {
    var target = runtime.stage;
    var scripts = target.data.scripts;
    if (scripts) {
        for (var s in scripts) {
            target.stacks.push(interp.makeBlockList(scripts[s][2]));
        }
    }
    $.each(this.data.children, function(index, obj) {
        target = runtime.sprites[index];
        if (typeof(target) != 'undefined' && target.data && target.data.scripts) {
            $.each(target.data.scripts, function(j, s) {
                target.stacks.push(interp.makeBlockList(s[2]));
            });
        }
    });
};

// Returns the number sprite we are rendering
// used for initial layering assignment
IO.prototype.getCount = function() {
    var rv = this.spriteLayerCount;
    this.spriteLayerCount++;
    return rv;
};

/*Interpreter.js*/

'use strict';

var Block = function(opAndArgs, optionalSubstack) {
    this.op = opAndArgs[0];
    this.primFcn = interp.lookupPrim(this.op);
    this.args = opAndArgs.slice(1); // arguments can be either or constants (numbers, boolean strings, etc.) or expressions (Blocks)
    this.isLoop = false; // set to true for loop blocks the first time they run
    this.substack = optionalSubstack;
    this.subStack2 = null;
    this.nextBlock = null;
    this.tmp = -1;
    interp.fixArgs(this);
};

var Thread = function(block, target) {
    this.nextBlock = block; // next block to run; null when thread is finished
    this.firstBlock = block;
    this.stack = []; // stack of enclosing control structure blocks
    this.target = target; // target object running the thread
    this.tmp = null; // used for thread operations like Timer
    this.tmpObj = []; // used for Sprite operations like glide
    this.firstTime = true;
    this.paused = false;
};

var Interpreter = function() {
    // Interpreter state
    this.primitiveTable = {}
    this.variables = {};
    this.threads = [];
    this.activeThread = new Thread(null);
    this.WorkTime = 30;
    this.currentMSecs = null;
    this.timer = new Timer();
    this.yield = false;
    this.doRedraw = false;
    this.opCount = 0; // used to benchmark the interpreter
    this.debugOps = false;
    this.debugFunc = null;
    this.opCount2 = 0;
};

// Utilities for building blocks and sequences of blocks
Interpreter.prototype.fixArgs = function(b) {
    // Convert the arguments of the given block into blocks or substacks if necessary.
    // A block argument can be a constant (numbers, boolean strings, etc.), an expression (Blocks), or a substack (an array of blocks).
    var newArgs = [];
    for (var i = 0; i < b.args.length; i++) {
        var arg = b.args[i];
        if (arg && arg.constructor == Array) {
            if ((arg.length > 0) && (arg[0].constructor == Array)) {
                // if first element arg is itself an array, then arg is a substack
                if (!b.substack) {
                    b.substack = this.makeBlockList(arg);
                } else {
                    b.substack2 = this.makeBlockList(arg);
                }
            } else {
                // arg is a block
                newArgs.push(new Block(arg));
            }
        } else {
            newArgs.push(arg); // arg is a constant
        }
    }
    b.args = newArgs;
};

Interpreter.prototype.makeBlockList = function(blockList) {
    var firstBlock = null, lastBlock = null;
    for (var i = 0; i < blockList.length; i++) {
        var b = new Block(blockList[i]);
        if (firstBlock == null) firstBlock = b;
        if (lastBlock) lastBlock.nextBlock = b;
        lastBlock = b;
    }
    return firstBlock;
};

// The Interpreter proper
Interpreter.prototype.stepThreads = function() {
    var startTime;
    startTime = this.currentMSecs = this.timer.time();
    this.doRedraw = false;
    if (this.threads.length == 0) return;

    while ((this.currentMSecs - startTime) < this.WorkTime && !this.doRedraw) {
        var threadStopped = false;
        for (var a = this.threads.length-1; a >= 0; --a) {
            this.activeThread = this.threads[a];
            this.stepActiveThread();
            if (!this.activeThread || this.activeThread.nextBlock == null) {
                threadStopped = true;
            }
        }
        if (threadStopped) {
            var newThreads = [];
            for (var a = this.threads.length-1; a >= 0; --a) {
                if (this.threads[a].nextBlock != null) {
                    newThreads.push(this.threads[a]);
                }
            }
            this.threads = newThreads;
            if (this.threads.length == 0) return;
        }
        this.currentMSecs = this.timer.time();
    }
};

Interpreter.prototype.stepActiveThread = function() {
    // Run the active thread until it yields.
    if (typeof(this.activeThread) == 'undefined') {
        return;
    }
    var b = this.activeThread.nextBlock;
    if (b == null) return;
    this.yield = false;
    while (true) {
        if (this.activeThread.paused) return;

        ++this.opCount;
        // Advance the "program counter" to the next block before running the primitive.
        // Control flow primitives (e.g. if) may change activeThread.nextBlock.
        this.activeThread.nextBlock = b.nextBlock;
        if (this.debugOps && this.debugFunc) {
            var finalArgs = [];
            for (var i = 0; i < b.args.length; ++i) {
                finalArgs.push(this.arg(b, i));
            }

            this.debugFunc(this.opCount2, b.op, finalArgs);
            ++this.opCount2;
        }
        b.primFcn(b);
        if (this.yield) { this.activeThread.nextBlock = b; return; }
        b = this.activeThread.nextBlock; // refresh local variable b in case primitive did some control flow
        while (!b) {
            // end of a substack; pop the owning control flow block from stack
            // Note: This is a loop to handle nested control flow blocks.

            // yield at the end of a loop or when stack is empty
            if (this.activeThread.stack.length === 0) {
                this.activeThread.nextBlock = null;
                return;
            } else {
                b = this.activeThread.stack.pop();
                if (b.isLoop) {
                    this.activeThread.nextBlock = b; // preserve where it left off
                    return;
                } else {
                    b = b.nextBlock; // skip and continue for non looping blocks
                }
            }
        }
    }
};

Interpreter.prototype.toggleThread = function(b, targetObj) {
    var newThreads = [], wasRunning = false;
    for (var i = 0; i < this.threads.length; i++) {
        if (this.threads[i].stack[0] == b) {
            wasRunning = true;
        } else {
            newThreads.push(this.threads[i]);
        }
    }
    this.threads = newThreads;
    if (!wasRunning) {
        this.startThread(b, targetObj);
    }
}

Interpreter.prototype.startThread = function(b, targetObj) {
    this.activeThread = new Thread(b, targetObj);
    this.threads.push(this.activeThread);
};

Interpreter.prototype.restartThread = function(b, targetObj) {
    // used by broadcast; stop any thread running on b, then start a new thread on b
    var newThread = new Thread(b, targetObj);
    var wasRunning = false;
    for (var i = 0; i < this.threads.length; i++) {
        if (this.threads[i].stack[0] == b) {
            this.threads[i] = newThread;
            wasRunning = true;
        }
    }
    if (!wasRunning) {
        this.threads.push(newThread);
    }
};

Interpreter.prototype.arg = function(block, index) {
    var arg = block.args[index];
    if ((typeof(arg) == 'object') && (arg.constructor == Block)) {
        ++this.opCount;
        if (this.debugOps && this.debugFunc) {
            var finalArgs = [];
            for (var i = 0; i < arg.args.length; ++i) {
                finalArgs.push(this.arg(arg, i));
            }

            this.debugFunc(this.opCount2, arg.op, finalArgs);
            ++this.opCount2;
        }
        return arg.primFcn(arg); // expression
    }
    return arg;
};

Interpreter.prototype.numarg = function(block, index) {
    var arg = Number(this.arg(block, index));
    if (arg !== arg) {
        return 0;
    }
    return arg;
};

Interpreter.prototype.boolarg = function(block, index) {
    var arg = this.arg(block, index);
    if (typeof arg === 'boolean') {
        return arg;
    } else if (typeof arg === 'string') {
        return !(arg === '' || arg === '0' || arg.toLowerCase() === 'false');
    }
    return Boolean(arg);
};

Interpreter.prototype.targetSprite = function() {
    return this.activeThread.target;
};

Interpreter.prototype.targetStage = function() {
    return runtime.stage;
};

// Timer
Interpreter.prototype.startTimer = function(secs) {
    var waitMSecs = 1000 * secs;
    if (waitMSecs < 0) waitMSecs = 0;
    this.activeThread.tmp = this.currentMSecs + waitMSecs; // end time in milliseconds
    this.activeThread.firstTime = false;
    this.yield = true;
};

Interpreter.prototype.checkTimer = function() {
    // check for timer expiration and clean up if expired. return true when expired
    if (this.currentMSecs >= this.activeThread.tmp) {
        // time expired
        this.activeThread.tmp = 0;
        this.activeThread.firstTime = true;
        return true;
    } else {
        this.yield = true;
        return false;
    }
};

Interpreter.prototype.redraw = function() {
    this.doRedraw = true;
};

// Primitive operations
Interpreter.prototype.initPrims = function() {
    this.primitiveTable = {};
    this.primitiveTable['whenGreenFlag']       = this.primNoop;
    this.primitiveTable['whenKeyPressed']      = this.primNoop;
    this.primitiveTable['whenClicked']         = this.primNoop;
    this.primitiveTable['if']                  = function(b) { if (interp.boolarg(b, 0)) interp.startSubstack(b); };
    this.primitiveTable['doForever']           = function(b) { interp.startSubstack(b, true); };
    this.primitiveTable['doForeverIf']         = function(b) { if (interp.boolarg(b, 0)) interp.startSubstack(b, true); else interp.yield = true; };
    this.primitiveTable['doIf']                = function(b) { if (interp.boolarg(b, 0)) interp.startSubstack(b); };
    this.primitiveTable['doRepeat']            = this.primRepeat;
    this.primitiveTable['doIfElse']            = function(b) { if (interp.boolarg(b, 0)) interp.startSubstack(b); else interp.startSubstack(b, false, true); };
    this.primitiveTable['doWaitUntil']         = function(b) { if (!interp.boolarg(b, 0)) interp.yield = true; };
    this.primitiveTable['doUntil']             = function(b) { if (!interp.boolarg(b, 0)) interp.startSubstack(b, true); };
    this.primitiveTable['doReturn']            = function(b) { interp.activeThread = new Thread(null); };
    this.primitiveTable['stopAll']             = function(b) { interp.activeThread = new Thread(null); interp.threads = []; }
    this.primitiveTable['whenIReceive']        = this.primNoop;
    this.primitiveTable['broadcast:']          = function(b) { interp.broadcast(b, false); };
    this.primitiveTable['doBroadcastAndWait']  = function(b) { interp.broadcast(b, true); };
    this.primitiveTable['wait:elapsed:from:']  = this.primWait;

    // added by John:
    this.primitiveTable['showBubble'] = function(b) { console.log(interp.arg(b, 1)); };
    this.primitiveTable['timerReset'] = function(b) { interp.timerBase = Date.now(); };
    this.primitiveTable['timer'] = function(b) { return (Date.now() - interp.timerBase) / 1000; };

    new Primitives().addPrimsTo(this.primitiveTable);
};

Interpreter.prototype.timerBase = Date.now();
Interpreter.prototype.lookupPrim = function(op) {
    var fcn = interp.primitiveTable[op];
    if (fcn == null) fcn = function(b) { console.log('not implemented: ' + b.op); };
    return fcn;
};

Interpreter.prototype.primNoop = function(b) { console.log(b.op); };

Interpreter.prototype.primWait = function(b) {
    if (interp.activeThread.firstTime) {
        interp.startTimer(interp.numarg(b, 0));
    } else {
        interp.checkTimer();
    }
};

Interpreter.prototype.primRepeat = function(b) {
    if (b.tmp == -1) {
        b.tmp = Math.max(interp.numarg(b, 0), 0); // Initialize repeat count on this block
    }
    if (b.tmp > 0) {
        b.tmp -= 1; // decrement count
        interp.startSubstack(b, true);
    } else {
        // Done executing this repeat block for this round
        b.tmp = -1;
        b = null;
    }
};

Interpreter.prototype.broadcast = function(b, waitFlag) {
    var pair;
    if (interp.activeThread.firstTime) {
        var receivers = [];
        var msg = String(interp.arg(b, 0)).toLowerCase();
        var findReceivers = function(stack, target) {
            if ((stack.op == 'whenIReceive') && (stack.args[0].toLowerCase() == msg)) {
                receivers.push([stack, target]);
            }
        }
        runtime.allStacksDo(findReceivers);
        for (pair in receivers) {
            interp.restartThread(receivers[pair][0], receivers[pair][1]);
        }
        if (!waitFlag) return;
        interp.activeThread.tmpObj = receivers;
        interp.activeThread.firstTime = false;
    }
    var done = true;
    for (pair in interp.activeThread.tmpObj) {
        if (interp.isRunning(interp.activeThread.tmpObj[pair][0])) {
            done = false;
        }
    }
    if (done) {
        interp.activeThread.tmpObj = null;
        interp.activeThread.firstTime = true;
    } else {
        interp.yield = true;
    }
};

Interpreter.prototype.isRunning = function(b) {
    for (t in interp.threads) {
        if (interp.threads[t].firstBlock == b) {
            return true;
        }
    }
    return false;
};

Interpreter.prototype.startSubstack = function(b, isLoop, secondSubstack) {
    // Start the substack of a control structure command such as if or forever.
    b.isLoop = !!isLoop;
    this.activeThread.stack.push(b); // remember the block that started the substack
    if (!secondSubstack) {
        this.activeThread.nextBlock = b.substack;
    } else {
        this.activeThread.nextBlock = b.substack2;
    }
};
